h2. Rails'e Başlamak

Bu klavuz Ruby on Rails'i kurmanız ve çalıştırmanız için gerekenleri içerir. Onu okuduktan sonra şu konularda bilgi sahibi olacaksınız:

* Rails Kurulumu, yeni bir Rails uygulaması üretimi ve uygulamanızın bir veritabanına bağlantısı
* Bir Rails uygulamasının genel yapısı
* MVC (Model, View Controller) ve RESTful tasarımın temel prensipleri
* Bir Rails uygulamasının başlangıç kısımlarını nasıl çabukça üretirsiniz.

endprologue.

UYARI. Bu klavuz Rails 3.0 a göre düzenlenmiştir. Burada gösterilen bazı kodlar önceki Rails versiyonlarında çalışmaz.

h3. Klavuzun Varsayımları

Bu klavuz Rails'e sıfırdan başlamak isteyen yeni programcılar için düzenlenmiştir. Daha önceden herhangi bir Rails bilginiz olmasını beklemez. Ancak, başlamadan önce şu bileşenlerin kurulu olması gerekir:

* "Ruby":http://www.ruby-lang.org/en/downloads programlama dili versiyon 1.8.7 ya da daha yüksek olmalı

İPUCU: Ruby 1.8.7 p248 ve p249 Rails 3.0'ın çakılmasına neden olan bug'lar içeriyordu. Ruby Enterprise Edition release 1.8.7-2010.02 den itibaren bu düzeltildi. Ruby 1.9.1 ise Rails 3.0'da segfault hataları veriyor, o yüzden 1.9.x serisiyle Rails 3.0 kullanmak isterseniz Ruby 1.9.2 den itibaren kullanın.

* "RubyGems":http://rubyforge.org/frs/?group_id=126 paketleme sistemi
* Çalışan bir "SQLite3 Veritabanı":http://www.sqlite.org

Rails, Ruby programlama dili üzerinden çalışan bir web uygulama geliştirme iskeletidir. Eğer Ruby hakkında önceden bilginiz yoksa, Rails öğrenirken zorlanacaksınız. Ruby öğrenmek için birçok bedava kaynak vardır, bazıları şunlar:

* "Mr. Neighborly's Humble Little Ruby Book":http://www.humblelittlerubybook.com
* "Programming Ruby":http://www.ruby-doc.org/docs/ProgrammingRuby/
* "Why's (Poignant) Guide to Ruby":http://mislav.uniqpath.com/poignant-guide/

h3. Rails Nedir?

Rails, Ruby programlama dili üzerinden çalışan bir web uygulama geliştirme iskeletidir. Her geliştiricinin başlarken ihtiyaç duyacağı şeyler hakkında varsayımlarda bulunarak web uygulamalarının yapılmasını kolaylaştırmak için tasarlanmıştır. Diğer benzerlerinden çok daha az kod yazarak başarıya ulaşmanızı sağlar. Uzmanlaşmış Rails kullanıcıları web uygulaması geliştirmenin eğlenceli hale getirildiğini de söyler.

Rails dikkafalı bir yazılımdır. Birşeyleri yapmanın en iyi yolu olduğunu ve kendisinin bu yolu kullandığını savunur ve bazen diğer yolları da inkar eder. Eğer "Rails yolu"nu öğrenirseniz, yüksek ihtimalle üretkenliğinizde büyük bir atış olduğunu göreceksiniz. Eğer daha önceki tecrübelerinizden yada bildiğiniz dillerden birşeyleri uygulamaya kalkarsanız daha başarısız olursunuz.

Rails filozofisi birkaç temel üzerine oturmuştur :

* DRY - "Dont Repeat Yourself (kendini tekrar edip durma)" - Aynı kodu tekrar tekrar yazmanın kötü birşey olduğunu savunur.
* Convention Over Configuration - Konfigürasyon kuralları koyar. Rails sizin na yapacağınıza ve nasıl yapacağınıza dair varsayımlarda bulunarak her küçük ayrıntıyı sayısız defa ayarlamanızı engeller.
* REST kaynaklarınızı ve standart HTTP işlerini en hızlı ilerlenecek şekilde ayarlayan bir web uygulama düzenidir.

h4. MVC Mimarisi

Rails'in merkezi Model, View, Controller mimarisidir, genellikle MVC diye çağrılır. MVC'nin avantajları şunlar :

* Kullanıcı arabirimi ile iş yapan lojiği biribrinden ayırır.
* DRY prensiplerine bağlı kalmayı kolaylaştırır.
* Farklı tiplerde kodlamaların berraklığı sayesinde bakım ve modifikasyon kolaylaşır.

h5. Modeller

Bir model, uygulama ve verileri arasındaki işlemleri sağlar. Rails yapısında modeller esas olarak bağlı veritabanı ile iletişimin kurallarını yönetir. Birçok durumda veri tabanınızdaki her tabloya karşı uygulamanızda bir model olacaktır. Uygulamanızın arkaplandaki lojiği çoğunlukla bu modeller üzerinde işlem yapacaktır.

h5. View'lar (Görseller)

Görseller uygulamanızın kullanıcı arabirimini oluştururlar. Rails'de görseller, genellikle görevleri veriyi sunmak olan ruby kodlarıyla birleştirilmiş HTML dosyalarıdır. Görseller internet tarayıcılarında verileri göstermek veya uygulamanızdan yapılacak istekleri iletmede kullanılır.

h5. Controller'lar 

Kontrolörler, modeller ve görseller arasında birleştirici görevi yaparlar. Rails'de kontrolörler, webten gelen istekleri işlemekle, modelleri veri için sorgulamakla ve verileri kullanıcıya sunulması için görsellere iletmekle sorumludurlar.

h4. Rails'in Bileşenleri

Rails, birçok özgün bileşenle birlikte gelir.

* Action Pack
  ** Action Controller
  ** Action Dispatch
  ** Action View
* Action Mailer
* Active Model
* Active Record
* Active Resource
* Active Support
* Railties


h5. Action Pack (Eylem Paketi)

Action Pack içinde Action Controller, Action View ve Action Dispatch bileşenlerinden oluşan tek bir gem'dir. MVC'nin VC parçasını oluşturur.

h5. Action Controller (kontrolör eylemleri)

Action Controller, bir Rails uygulamasında kontrolörleri yönetir. Action Controller, Rails uygulamasına gelen istekleri işleyerek parametreleri ayırır ve onları ilgili eylemlere dağıtır. Action Controller tarafından sağlanan servisler içinde oturum yönetimi, görsel kalıpların yayınlanması ve yönlendirmeler vardır.

h5. Action View (görsel eylemleri)

Action View, Rails uygulamanızdaki görselleri yönetir. Default olarak HTML ve XML çıktı üretebilir. Action View, görsel kalıpları yönetir. Bunlar içinde içiçe kalıpların işlenmesi ve Ajax desteği de vardır.

h5. Action Dispatch (dağıtım eylemleri)

Action Dispatch, gelen web isteklerinin yönlendirilmesini yönetir ve istediğiniz şekilde sizin uygulamanıza veya diğer bir Rack uygulamasına dağıtımını sağlar. 

h5. Action Mailer

Action Mailer, e-mail servisleri üretmek için bir iskelettir. Action Mailer'ı gelen mailleri işlemekte ve basit bir yazıdan birçok kalıplarda komplex e-maillere kadar mail hazırlayıp göndermede kullanabilirsiniz.

h5. Active Model

Active Model, Action Pack gem servisleri ve Active Record gibi obje ilişkileri yönlendirme gemleri arasında bir bağlaşım sağlar. Active Model ile Active Record yerine eğer uygulmanızın ihtiyacı varsa diğer ORM iskeletleri de kullanabilirsiniz.

h5. Active Record

Active Record bir Rails uygulamasında modeller için temeldir. Veri tabanından bağımsız olmayı, basit CRUD işlevlerini ve modellerin bir diğerleriyle ilişkisini sağlar.

h5. Active Resource

Active Resource, işlevsel nesnelerle REST temelli web servisleri arasında bağlantı sağlayan bir iskelet sağlar. CRUD mantığıyla web temelli kaynaklar ve yerel nesneler arasında bir yol çizer.

h5. Active Support

Active Support, Rails uygulamaları için yazılmış, hem merkezde hem uygulamanızda kullanılan gelişmiş birçok Ruby kütüphane ilaveleri içerir.

h5. Railties

Railties yeni bir Rails uygulaması için kod üretmekte ve değişik iskeletlerle plugin'leri Rails uygulamasında içermek için kullanılan merkez ünitedir.

h4. REST

Rest, Representational State Transfer cümlesini ifade eder ve RESTfull mimarisinin temelidir. Bu Roy Fielding'in ağ temelli yazılım mimarileri ve stillerini belirten doktora tezinden esinlenmiştir. Bu teze göre Rails uygulamasına şu ana özellikler kazandırılmıştır :

* Kaynakları gösteren URL ler benzeri kaynak imleri kullanmak.
* Sistem bileşenleri arasında kaynakların durumunu taşımak.

Örneğin Bir Rails uygulamasına şöyle bir istek gelsin :

<tt>DELETE /photos/17</tt>

 yazımından anlaşılacağı gibi id'si 17 olan bir fotoğrafın silinmesi isteğidir. REST web uygulamaları için doğal bir yöntemdir ve Rails bunu yöneterek sizi birçok karmaşık işten ve tarayıcı süprizlerinden kurtarır.

Eğer REST yapısı hakkında ve Fielding'in tezi hakkında daha fazla bilgi sahibi olmak isterseniz bu kaynaklara bakabilirsiniz :

* "A Brief Introduction to REST":http://www.infoq.com/articles/rest-introduction by Stefan Tilkov
* "An Introduction to REST":http://bitworking.org/news/373/An-Introduction-to-REST (video tutorial) by Joe Gregorio
* "Representational State Transfer":http://en.wikipedia.org/wiki/Representational_State_Transfer article in Wikipedia
* "How to GET a Cup of Coffee":http://www.infoq.com/articles/webber-rest-workflow by Jim Webber, Savas Parastatidis & Ian Robinson

h3. Yeni Bir Rails Projesi Üretmek

Eğer bu klavuzu takip ederseniz, <tt>blog</tt> adında bir Rails uygulaması üreteceksiniz, çok basit bir web günlüğü. Uygulamayı inşa etmeye başlamadan önce, Rails'in sisteminizde kurulu olduğundan emin olmalısınız.

h4. Rails Kurulumu

Birçok durumda, Rails kurmanın en kolay yolu RubyGems avantajını kullanmak olacaktır:

<shell>
Genellikle bu komutu root kullanıcı olarak çalıştırmanız gerekir: 
# gem install rails
</shell>

İPUCU. Eğer Windows kullanıyorsanız, Instant Rails'in kurulumunu daha basit bulacaksınız. Gerçi Instant Rails en son versiyondan genelde geride kalıyor ama. Ayrıca windos üzerinde Rails geliştirme yapmak diğer sistemlere nazaran daha keyifsizdir. Eğer mümkünse tavsiyemiz windows yerine bir Linux sanal makina yardımıyla Rails çalışmanızdır.

h4. Blog Uygulmasını Üretmek

Bu klavuzu kullanmanın en iyi yolu sırası geldiğinde her adımı takip etmek, bu örneği yapmak için gereken hiçbir kodlama dışarda bırakılmamıştır. Bu yüzden adım adım izleyebilirsiniz. Eğer bitmiş kodu görmek isterseniz, "Getting Started Code":http://github.com/mikel/getting-started-code dan indirebilirsiniz.

Başlamak için bir konsol (terminal) açın ve uygulamanızı koymak istediğiniz ve dosya yazma hakkınızın bulunduğu bir klasöre gidin ve şunu yazın:

<shell>
$ rails new blog
</shell>

Bu "blog" adlı klasör içinde Blog ismi verilen bir uygulama üretecektir.

İPUCU: Rails Uygulama Üretecinin tüm komut satır parametrelerini <tt>rails -h</tt> komutuyla görebilirsiniz.

Uygulamanın üretilmesini hata mesajı almadan birçok dosya oluşturulmasından gördükten sonra uygulamanın bulunduğu klasöre geçin:

<shell>
$ cd blog
</shell>

Rails blog adında bir klasör oluşturdu. Bu klasörü açın ve inceleyin. Bu tutorial'de çoğunlukla "app" klasöründe çalışılacak fakat Rails'in ürettiği klasörlerde basit bir gezinti yapalım:

|_.Dosya/Klasör|_.Amacı|
|Gemfile| Bu dosya Rails uygulamanızın hangi Gem'lere bağlantılı olduğunu belirtir.|
|README|README dosyası uygulamanız hakkında kısa bilgi bulundurmalıdır. Onda uygulamanızın ne iş yaptığını, nasıl ayarlandığını vb. bilgileri bulundurmalısınız.|
|Rakefile|Bu dosyada terminalden çalıştırılabilen batch işler bulunur.|
|app/|Bu klasörde uygulamanızın kontrolör ve görselleri bulunur. Bu klavuzun geri kalan kısmında bu klasöre yoğunlaşacaksınız.|
|config/|uygulamanızın çalışma kuralları. yönlendirmeleri, ve veritabanı ayarlamaları vs. bu klasördedir.|
|config.ru|Rack temelli serverlar için uygulamayı başlatma konfigürasyonları.|
|db/|Veritabanınızın yapısını barındırır. Ayrıca veritabanı birleştirmelerini (Migration) içerir. Birleştirmeleri ilerde göreceksiniz.|
|doc/|Uygulamanızın dokümanları bu klasördedir.|
|lib/|Uygulamanızın genişlemesi için modüller buradadır. (bu klavuzda anlatılmamıştır).|
|log/|Uygulamanın log dosyaları.|
|public/|Dış dünyadan olduğu şekliyle ulaşılabilen yegane dosyalar buradadır. Burada tüm resimleriniz, javascriptleriniz, stilleriniz ve diğer sunacağınız dosyalar bulunur.|
|script/|Uygulamanızı çalıştırmak ve yükleme ve diğer çalışma işlevlerinin script'leri içeren klasör.|
|test/|Test işlemleri , bağlayıcılar ve diğer test yardımcıları buradadır. Bu konular "Rails uygulamasının test edilmesi":testing.html bölümünde işlenecek.|
|tmp/|Geçici dosyalar|
|vendor/|Tüm 3. parti yazılımları buradadır. Tipik bir Rails uygulamasında, Gem dosyaları, pluginler ve projenizin içine gömecekseniz Rails kaynak kodu bulunur.|

h4. Gerekli Gemlerin Kurulması

Rails uygulamanızın kullandığı tüm gemleri vendor klasöründe işlemek için "Bundler":http://gembundler.com/v1.0/index.html gemi kullanır. Default olan dışında özel bir gem kullanmayacağımız için sadece şunu yapmamız gerekiyor:

<shell>
# bundle install
</shell>

h4. Bir Veritabanı Tanıtmak

Hemen tüm Rails uygulamaları bir veritabanı kullanır. Kullanılacak veritabanı +config/database.yml+ dosyasında tarif edilir. 
Eğer yeni bir Rails uygulamasında bu dosyayı açarsanız SQLITE3 bir veritabanı tarif edildiğini görürsünüz. Bu dosyada Railsin kullandığı 3 değişik ortama ait kısımlar vardır:

* +Development+ (geliştirme) ortamı uygulamanızı geliştirirken manual iletişim kurabileceğiniz ortamdır.
* +Test+ ortamı uygulamanın otomatize testlerini çalıştırabileceğiniz ortamdır.
* +Production+ (üretim) ortamı uygulamanızı dünyanın kullanımı için yayınlamanızda kullanılır.

h5. Bir SQLite3 veritabanı düzenlemek

Rails, hafif server'sız bir veritabanı olan SQLite3 desteği ile gelir. Çok çalışan uygulamalar SQLite3 veritabanını zorlasa da geliştirme ortamı için idealdir. Rails yeni bir uygulama başlattığında SQLite3 olarak yapılanır ama istediğiniz zaman değiştirebilirsiniz.

Bunlar geliştirme ortamı bölümü için (<tt>config/database</tt>) dosyasının default yapılandırması :

<yaml>
development:
  adapter: sqlite3
  database: db/development.sqlite3
  pool: 5
  timeout: 5000
</yaml>

NOTE: Bu klavuzda verilerimizi saklamak için bir SQLite3 veritabanı kullanıyoruz, bu yüzden veritabanı konfigürasyon dosyasında bir değişiklik yapmamıza gerek yok. Rails ayrıca MySQL ve PrstgreSQL destekler ve diğer birçok veritabanları için plugin'leri  vardır. Eğer halihazırda kullandığınız bir veritabanı varsa Rails'in yüksek ihtimalle ona uygun bir adaptörü vardır.

h5. MySQL Veritabanı Konfigürasyonu

Eğer birlikte gelen SQLite3 veritabanı yerine MySQL kullanmayı tercih ederseniz, database.yml dosyanız farklı olmalıdır. İşte geliştirme ortamı bölümü:

<yaml>
development:
  adapter: mysql2
  encoding: utf8
  database: blog_development
  pool: 5
  username: root
  password:
  socket: /tmp/mysql.sock
</yaml>

Eğer geliştirme yatığınız bilgisayardaki MySQL server root kullanıcısı boş şifreyle çalışıyorsa bu konfigürasyon çalışacaktır. Aksi halde kullanıcı adı ve şifrenin server kullanıcısına uygun şekilde değiştirilmesi gerekir.

h5. PostgreSQL veritabanı konfigürasyonu

Son olarak, eğer PostgreSQL veritabanı kullanmayı tercih ederseniz "config/database.yml" dosyanız buna göre ayarlanmalıdır:

<yaml>
development:
  adapter: postgresql
  encoding: unicode
  database: blog_development
  pool: 5
  username: blog
  password:
</yaml>

Kullanıcı adı ve şifreyi doğru şekilde değiştirin.

h4. Veritabanı Oluşturulması

Şu anda veritabanı konfigürasyonunuz tamam, şimdi Rails'in sizin için boş bir veritabanı üretmesinin zamanı. Bunu şu komutu girerek yapabilirsiniz:

<shell>
$ rake db:create
</shell>

Bu komut <tt>db/</tt> klasöründe geliştirme ve test veritabanlarınızı oluşturur.

İPUCU: Rake komutu Rails'in birçok şey için kullandığı genel amaçlı bir kod çalıştırıcıdır. Olası komutları +rake -T+ komutu girerek görebilirsiniz.

h3. Merhaba Rails!

Yeni bir dile başlamanın klasik yolu ekrana yazılı birşeyler getirmektir. Rails'de bunun olması için uygulama server'ı çalıştırmalısınız.

h4. Web Server'ı Çalıştırmak

Aslında şu ana kadar yaptıklarınızla aktif bir Rails uygulamanız hazır. Bunu görmek için geliştirme makinenizde web server'ı başlatmanız gerekiyor:

<shell>
$ rails server
</shell>

Bu default olarak bir Mongrel web server başlatacaktır.(Rails diğer farklı server'lar da kullanabilir, mesela mongrel yoksa otomatikman webrick çalışır). Uygulamanızı çalışır şekilde görmek için bir tarayıcı açın ve "http://localhost:3000":http://localhost:3000 adresini girin. Rails'in default bilgilendirme ekranı gelecektir:

!images/rails_welcome.png(Welcome Aboard screenshot)!

İPUCU: Web server'ı durdurmak için çalıştırdığınız konsol ekranında Ctrl+C basmanız gerekir. Geliştirme modunda, genellikle Rails server'ı durdurmanız gerekmez; dosyalarda yaptığınız değişiklikler server'a otomatik yüklenecektir.

“Welcome Aboard” yeni bir Rails uygulamasının tüten buharıdır: uygulamanızın server'dan yayınlanması için herşeyn uygun olduğundan emin olmak içindir. Ayrıca _About your application’s environment_ bağlantısına tıklayarak uygulamanızın kullandığı ortam hakkında bilgi edinebilirsiniz.

h4. "Merhaba" de Rails

Railsin "Merhaba" demesi için, en az bir kontrolör ve bir görsel ihtiyacınız vardır. Çok şükür ki bunu tek komutla yapabilirsiniz. Şu komutu terminalden girin:

<shell>
$ rails generate controller home index
</shell>

İPUCU: Eğer Windows'taysanız yada Ruby kurulumunuz standart olmayan bir kurulumdaysa Ruby'ye rails komutunun yolunu da net olarak belirtmeniz gerekir: +ruby \path\to\rails generate controller home index+.

Rails sizin için bazı dosyalar üretecektir. Biri de +app/views/home/index.html.erb+. Bu +home+ kontrolörünün +index+ eylemi sayfasını göstermekte kullanılacak olan kalıp dosyadır. Bu dosyayı editörde açıp içine sadece şu satırı koyun gerisini silin:

<code class="html">
<h1>Merhaba Rails!</h1>
</code>

h4. Uygulamanın Ana Sayfasının Ayarlanması

Şimdiye kadar kontrolör ve görsel dosyasını hazırladık, Rails'e "Merhaba Rails" mesajını görmek istediğimizi anlatmalıyız. Bu durumda "http://localhost:3000":http://localhost:3000 adresi girince "Welcome Aboard" yerine hazırladığımız görselin çıkmasını istiyoruz.

Bunu yapmanın ilk adımı uygulamanın default sayfasını silmek:

<shell>
$ rm public/index.html
</shell>

Rails yayınlama yaparken +public+ klasöründeki statik dosyaları bizim kontrolörle ürettiğimiz dinamik dosyalara tercih edeceği için bunu yapmamız gerekir.

Şimdi Rails'e gerçek ana sayfanın nerede olduğunu anlamanız gerekiyor. +config/routes.rb+ dosyasını editörde açın. Bu uygulamanızın Rails'e gelen çağrılarını nasıl yönlendireceğini anlatan DSL(Domain Spesific Language) girdileri olan yönlendirme dosyasıdır. Bu dosyada başta sadece yorumlar vardır, bu yorumlarda örnek yönlendirmeler vardır. +root :to+ ile başlayan satırın yorum tikini kaldırın ve şu hale getirin:

<ruby>
Blog::Application.routes.draw do

  #...
  # You can have the root of your site routed with "root"
  # just remember to delete public/index.html.
  root :to => "home#index"
</ruby>

+root :to => "home#index"+ satırı Rails'e root eylemini "home" kontrolörü "index" eylemine yönlendirmesini anlatır. 

Eğer şimdi "http://localhost:3000":http://localhost:3000 adresine gidersek +Merhaba Rails!+ mesajını görebiliriz. 

NOT. Daha fazla bilgi için "Rails Routing from the Outside In":routing.html adresine bakınız.

h3. Scaffolding ile hızlı hazırlık ve çalıştırma.

Rails _Scaffolding_ uygulamanın ana parçalarının üretilmesi için hızlı bir yoldur. Modeller, görseller ve kontrolörleri bir kerede üretmek isterseniz scaffolding size gereken araçtır.

h3. Bir Kaynak Üretmek

Blog uygulamasına göre gönderilerin kaydedileceği bir "Post" kaynağı üreterek başlamak gerekir: bu bir tane blog gönderisi barındıracaktır. Bunu yapmak için konsoldan şu komutu girin:

<shell>
$ rails generate scaffold Post name:string title:string content:text
</shell>

NOT. Scaffolding'in kendi doğrultusunda hazırladığı kodu sizin tercihlerinize uymayabilir. Çoğunlukla ürettiği kodları değiştirmek gerekecektir. Uzmanlık kazanmış programcılar genellikle kodlarını baştan kendileri üretir. Ama başlangıç seviyesi için gereklidir.

Scaffold jeneratör uygulamanıza 15 dosya üretir, bazı klasörler üretir ve bazılarını da edit eder. Şimdi bunlara kısaca bakalım:

|_.Dosya                                       |_.Amacı|
|db/migrate/20100207214725_create_posts.rb    |Veritabanınızda posts tablosunu üretmek için birleştirme dosyasıdır. Dosya isminde üretildiği anın tarihi olduğu için sizin dosyanızın ismi değişik olacaktır.|
|app/models/post.rb                           |"Post" modelinin dosyası|
|test/fixtures/posts.yml                      |Test amaçlı hazırlanmış sahte gönderi verileri|
|app/controllers/posts_controller.rb          |Gönderilerin kontrolör dosyası|
|app/views/posts/index.html.erb               |Tüm gönderilerin yer aldığı görsel dosyası |
|app/views/posts/edit.html.erb                |Bir gönderiyi düzenlemek için görsel sayfası|
|app/views/posts/show.html.erb                |Birtek gönderiyi göstermek için görsel dosyası|
|app/views/posts/new.html.erb                 |Yeni bir gönderi hazırlama görseli|
|app/views/posts/_form.html.erb               |Hem edit hem new eyleminde kullanılan form görüntüsü parçası|
|app/helpers/posts_helper.rb                  |Post görsellerinde kullanmak için yardımcı fonksiyonlar|
|test/unit/post_test.rb                       |Gönderilerin modeli (posts) için birim test kalıbı|
|test/functional/posts_controller_test.rb     |Gönderilerin kontrolörü için fonksiyonel test kalıbı|
|test/unit/helpers/posts_helper_test.rb       |Yardımcılar için test kalıbı|
|config/routes.rb                             |Gönderiler için yönlendirmeler amacıyla düzenlendi|
|public/stylesheets/scaffold.css              |Scaffold ile hazırlanan görseller için hazırlanmış CSS dosyası|

h4. Veritabanı Birleştirme Yapılması (Migration)

+rails generate scaffold+ komutunun ürünlerinden biri de _veritabanı birleştirmesi_ dir. Birleştirmeler (Migration) veritabanı tablolarının üretilmesi ve değiştirilmesini basitleştirmek için kullanılan Ruby sınıflarıdır. Rails birleştirmeler için rake komutunu kullanır, ve bir birleştirme uygulandıktan sonra geri alınabilir. Birleştirme dosyaları, hangi sırada yapıldıklarından emin olmak için yapıldıkları zamanın kodunu içerirler.

Eğer +db/migrate/20100207214725_create_posts.rb+ dosyasının içine bakarsanız (hatırlayın, sizinkinin ismi farklı olacaktır), şunları bulursunuz:

<ruby>
class CreatePosts < ActiveRecord::Migration
  def self.up
    create_table :posts do |t|
      t.string :name
      t.string :title
      t.text :content

      t.timestamps
    end
  end

  def self.down
    drop_table :posts
  end
end
</ruby>

Yukardaki birleştirme iki metod üretir, +up+ bu birlştirmeyi çalıştırdığınızda aktif olur ve +down+ ilerde birleştirmeleri geri almak isterseniz çalışır. Bu görüntüde +up+ komutu +posts+ tablosunu iki string ve bir text sütunu ile oluşturur. Ayrıca kayıtların üretildiği ve update edildiği tarihler için de timestamp alanları üretir. Rails birleştirmeleri hakkında daha fazla bilgi "Rails Database Migrations":migrations.html klavuzunda bulunabilir.

Şimdi birleştirmenin gerçekleşmesi için rake komutu çalıştırın:

<shell>
$ rake db:migrate
</shell>

Rails birleştirme komutunu işletecek ve size +posts+ tablosunu ürettiğini bildirecektir.

<shell>
==  CreatePosts: migrating ====================================================
-- create_table(:posts)
   -> 0.0019s
==  CreatePosts: migrated (0.0020s) ===========================================
</shell>

NOT. Şu anda geliştirme ortamında çalıştığınız için bu komut +config/database.yml+ dosyasının +development+ kısmında belirtilen veritabanında işlem yapacaktır.

h4. Bir Bağlantı Eklemek

Önceden ürettiğiniz ana sayfaya gönderilere gitmek için bir bağlantı ekleyebilirsiniz. +app/views/home/index.html.erb+ dosyasını açın ve şöyle değiştirin:

<code lang="ruby">
<h1>Merhaba Rails!</h1>
<%= link_to "Bloğum", posts_path %>
</code>

+link_to+ metodu Rails'in içerdiği görsel yardımcılarından biridir. Yazılacak yazı ve gidilecek yer parametrelerinden bir hyperlink oluşturur - bu durumda gönderilere bağlantı kurulmuş.

h4. Tarayıcıda Gönderileri Çalışmak

Şimdi gönderilerle çalışmaya başlayabilirsiniz. Bunu yapmak için "http://localhost:3000":http://localhost:3000/ adresine gidin ve "Bloğum" linkini tıklayın:

!images/posts_index.png(Posts Index screenshot)!

Bu gönderilerin +index+ görsel sayfası için Rails'in sunusu sonucudur. There aren't currently any posts in the database, but if you click the +New Post+ link you can create one. After that, you'll find that you can edit posts, look at their details, or destroy them. All of the logic and HTML to handle this was built by the single +rails generate scaffold+ command.

TIP: In development mode (which is what you're working in by default), Rails reloads your application with every browser request, so there's no need to stop and restart the web server.

Congratulations, you're riding the rails! Now it's time to see how it all works.

h4. The Model

The model file, +app/models/post.rb+ is about as simple as it can get:

<ruby>
class Post < ActiveRecord::Base
end
</ruby>

There isn't much to this file - but note that the +Post+ class inherits from +ActiveRecord::Base+. Active Record supplies a great deal of functionality to your Rails models for free, including basic database CRUD (Create, Read, Update, Destroy) operations, data validation, as well as sophisticated search support and the ability to relate multiple models to one another.

h4. Adding Some Validation

Rails includes methods to help you validate the data that you send to models. Open the +app/models/post.rb+ file and edit it:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }
end
</ruby>

These changes will ensure that all posts have a name and a title, and that the title is at least five characters long. Rails can validate a variety of conditions in a model, including the presence or uniqueness of columns, their format, and the existence of associated objects.

h4. Using the Console

To see your validations in action, you can use the console. The console is a command-line tool that lets you execute Ruby code in the context of your application:

<shell>
$ rails console
</shell>

After the console loads, you can use it to work with your application's models:

<shell>
>> p = Post.new(:content => "A new post")
=> #<Post id: nil, name: nil, title: nil,
     content: "A new post", created_at: nil,
     updated_at: nil>
>> p.save
=> false
>> p.errors
=> #<OrderedHash { :title=>["can't be blank",
                           "is too short (minimum is 5 characters)"],
                   :name=>["can't be blank"] }>
</shell>

This code shows creating a new +Post+ instance, attempting to save it and getting +false+ for a return value (indicating that the save failed), and inspecting the +errors+ of the post.

When you're finished, type +exit+ and hit +return+ to exit the console.

TIP: Unlike the development web server, the console does not automatically load your code afresh for each line. If you make changes to your models while the console is open, type +reload!+ at the console prompt to load them.

h4. Listing All Posts

The easiest place to start looking at functionality is with the code that lists all posts. Open the file +app/controllers/posts_controller.rb+ and look at the +index+ action:

<ruby>
def index
  @posts = Post.all

  respond_to do |format|
    format.html # index.html.erb
    format.xml  { render :xml => @posts }
  end
end
</ruby>

+Post.all+ calls the +Post+ model to return all of the posts currently in the database. The result of this call is an array of posts that we store in a instance variable called +@posts+.

TIP: For more information on finding records with Active Record, see "Active Record Query Interface":active_record_querying.html.

The +respond_to+ block handles both HTML and XML calls to this action. If you browse to "http://localhost:3000/posts.xml":http://localhost:3000/posts.xml, you'll see all of the posts in XML format. The HTML format looks for a view in +app/views/posts/+ with a name that corresponds to the action name. Rails makes all of the instance variables from the action available to the view. Here's +app/views/posts/index.html.erb+:

<erb>
<h1>Listing posts</h1>

<table>
  <tr>
    <th>Name</th>
    <th>Title</th>
    <th>Content</th>
    <th></th>
    <th></th>
    <th></th>
  </tr>

<% @posts.each do |post| %>
  <tr>
    <td><%= post.name %></td>
    <td><%= post.title %></td>
    <td><%= post.content %></td>
    <td><%= link_to 'Show', post %></td>
    <td><%= link_to 'Edit', edit_post_path(post) %></td>
    <td><%= link_to 'Destroy', post, :confirm => 'Are you sure?', :method => :delete %></td>
  </tr>
<% end %>
</table>

<br />

<%= link_to 'New post', new_post_path %>
</erb>

This view iterates over the contents of the +@posts+ array to display content and links. A few things to note in the view:

* +link_to+ builds a hyperlink to a particular destination
* +edit_post_path+ and +new_post_path+ are helpers that Rails provides as part of RESTful routing. You'll see a variety of these helpers for the different actions that the controller includes.

NOTE. In previous versions of Rails, you had to use +&lt;%=h post.name %&gt;+ so that any HTML would be escaped before being inserted into the page.  In Rails 3.0, this is now the default.  To get unescaped HTML, you now use +&lt;%= raw post.name %&gt;+.

TIP: For more details on the rendering process, see "Layouts and Rendering in Rails":layouts_and_rendering.html.

h4. Customizing the Layout

The view is only part of the story of how HTML is displayed in your web browser. Rails also has the concept of +layouts+, which are containers for views. When Rails renders a view to the browser, it does so by putting the view's HTML into a layout's HTML. In previous versions of Rails, the +rails generate scaffold+ command would automatically create a controller specific layout, like +app/views/layouts/posts.html.erb+, for the posts controller. However this has been changed in Rails 3.0. An application specific +layout+ is used for all the controllers and can be found in +app/views/layouts/application.html.erb+. Open this layout in your editor and modify the +body+ tag:

<erb>
<!DOCTYPE html>
<html>
<head>
  <title>Blog</title>
  <%= stylesheet_link_tag :all %>
  <%= javascript_include_tag :defaults %>
  <%= csrf_meta_tags %>
</head>
<body style="background: #EEEEEE;">

<%= yield %>

</body>
</html>
</erb>

Now when you refresh the +/posts+ page, you'll see a gray background to the page. This same gray background will be used throughout all the views for posts.

h4. Creating New Posts

Creating a new post involves two actions. The first is the +new+ action, which instantiates an empty +Post+ object:

<ruby>
def new
  @post = Post.new

  respond_to do |format|
    format.html # new.html.erb
    format.xml  { render :xml => @post }
  end
end
</ruby>

The +new.html.erb+ view displays this empty Post to the user:

<erb>
<h1>New post</h1>

<%= render 'form' %>

<%= link_to 'Back', posts_path %>
</erb>

The +&lt;%= render 'form' %&gt;+ line is our first introduction to _partials_ in Rails.  A partial is a snippet of HTML and Ruby code that can be reused in multiple locations.  In this case, the form used to make a new post, is basically identical to a form used to edit a post, both have text fields for the name and title and a text area for the content with a button to make a new post or update the existing post.

If you take a look at +views/posts/_form.html.erb+ file, you will see the following:

<erb>
<%= form_for(@post) do |f| %>
  <% if @post.errors.any? %>
  <div id="errorExplanation">
    <h2><%= pluralize(@post.errors.count, "error") %> prohibited this post from being saved:</h2>
    <ul>
    <% @post.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
  <% end %>

  <div class="field">
    <%= f.label :name %><br />
    <%= f.text_field :name %>
  </div>
  <div class="field">
    <%= f.label :title %><br />
    <%= f.text_field :title %>
  </div>
  <div class="field">
    <%= f.label :content %><br />
    <%= f.text_area :content %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>
</erb>

This partial receives all the instance variables defined in the calling view file, so in this case, the controller assigned the new Post object to +@post+ and so, this is available in both the view and partial as +@post+.

For more information on partials, refer to the "Layouts and Rendering in Rails":layouts_and_rendering.html#using-partials guide.

The +form_for+ block is used to create an HTML form. Within this block, you have access to methods to build various controls on the form. For example, +f.text_field :name+ tells Rails to create a text input on the form, and to hook it up to the +name+ attribute of the instance being displayed. You can only use these methods with attributes of the model that the form is based on (in this case +name+, +title+, and +content+). Rails uses +form_for+ in preference to having you write raw HTML because the code is more succinct, and because it explicitly ties the form to a particular model instance.

The +form_for+ block is also smart enough to work out if you are doing a _New Post_ or an _Edit Post_ action, and will set the form +action+ tags and submit button names appropriately in the HTML output.

TIP: If you need to create an HTML form that displays arbitrary fields, not tied to a model, you should use the +form_tag+ method, which provides shortcuts for building forms that are not necessarily tied to a model instance.

When the user clicks the +Create Post+ button on this form, the browser will send information back to the +create+ method of the controller (Rails knows to call the +create+ method because the form is sent with an HTTP POST request; that's one of the conventions that I mentioned earlier):

<ruby>
def create
  @post = Post.new(params[:post])

  respond_to do |format|
    if @post.save
      format.html { redirect_to(@post,
                    :notice => 'Post was successfully created.') }
      format.xml  { render :xml => @post,
                    :status => :created, :location => @post }
    else
      format.html { render :action => "new" }
      format.xml  { render :xml => @post.errors,
                    :status => :unprocessable_entity }
    end
  end
end
</ruby>

The +create+ action instantiates a new Post object from the data supplied by the user on the form, which Rails makes available in the +params+ hash. After successfully saving the new post, +create+ returns the appropriate format that the user has requested (HTML in our case). It then redirects the user to the resulting post +show+ action and sets a notice to the user that the Post was successfully created.

If the post was not successfully saved, due to a validation error, then the controller returns the user back to the +new+ action with any error messages so that the user has the chance to fix the error and try again.

The "Post was successfully created." message is stored inside of the Rails +flash+ hash, (usually just called _the flash_) so that messages can be carried over to another action, providing the user with useful information on the status of their request. In the case of +create+, the user never actually sees any page rendered during the Post creation process, because it immediately redirects to the new Post as soon Rails saves the record. The Flash carries over a message to the next action, so that when the user is redirected back to the +show+ action, they are presented with a message saying "Post was successfully created."

h4. Showing an Individual Post

When you click the +show+ link for a post on the index page, it will bring you to a URL like +http://localhost:3000/posts/1+. Rails interprets this as a call to the +show+ action for the resource, and passes in +1+ as the +:id+ parameter. Here's the +show+ action:

<ruby>
def show
  @post = Post.find(params[:id])

  respond_to do |format|
    format.html # show.html.erb
    format.xml  { render :xml => @post }
  end
end
</ruby>

The +show+ action uses +Post.find+ to search for a single record in the database by its id value. After finding the record, Rails displays it by using +show.html.erb+:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>


<%= link_to 'Edit', edit_post_path(@post) %> |
<%= link_to 'Back', posts_path %>
</erb>

h4. Editing Posts

Like creating a new post, editing a post is a two-part process. The first step is a request to +edit_post_path(@post)+ with a particular post. This calls the +edit+ action in the controller:

<ruby>
def edit
  @post = Post.find(params[:id])
end
</ruby>

After finding the requested post, Rails uses the +edit.html.erb+ view to display it:

<erb>
<h1>Editing post</h1>

<%= render 'form' %>

<%= link_to 'Show', @post %> |
<%= link_to 'Back', posts_path %>
</erb>

Again, as with the +new+ action, the +edit+ action is using the +form+ partial, this time however, the form will do a PUT action to the PostsController and the submit button will display "Update Post"

Submitting the form created by this view will invoke the +update+ action within the controller:

<ruby>
def update
  @post = Post.find(params[:id])

  respond_to do |format|
    if @post.update_attributes(params[:post])
      format.html { redirect_to(@post,
                    :notice => 'Post was successfully updated.') }
      format.xml  { head :ok }
    else
      format.html { render :action => "edit" }
      format.xml  { render :xml => @post.errors,
                    :status => :unprocessable_entity }
    end
  end
end
</ruby>

In the +update+ action, Rails first uses the +:id+ parameter passed back from the edit view to locate the database record that's being edited. The +update_attributes+ call then takes the rest of the parameters from the request and applies them to this record. If all goes well, the user is redirected to the post's +show+ view. If there are any problems, it's back to the +edit+ view to correct them.

h4. Destroying a Post

Finally, clicking one of the +destroy+ links sends the associated id to the +destroy+ action:

<ruby>
def destroy
  @post = Post.find(params[:id])
  @post.destroy

  respond_to do |format|
    format.html { redirect_to(posts_url) }
    format.xml  { head :ok }
  end
end
</ruby>

The +destroy+ method of an Active Record model instance removes the corresponding record from the database. After that's done, there isn't any record to display, so Rails redirects the user's browser to the index view for the model.

h3. Adding a Second Model

Now that you've seen how a model built with scaffolding looks like, it's time to add a second model to the application. The second model will handle comments on blog posts.

h4. Generating a Model

Models in Rails use a singular name, and their corresponding database tables use a plural name. For the model to hold comments, the convention is to use the name Comment. Even if you don't want to use the entire apparatus set up by scaffolding, most Rails developers still use generators to make things like models and controllers. To create the new model, run this command in your terminal:

<shell>
$ rails generate model Comment commenter:string body:text post:references
</shell>

This command will generate four files:

* +app/models/comment.rb+ - The model
* +db/migrate/20100207235629_create_comments.rb+ - The migration
* +test/unit/comment_test.rb+ and +test/fixtures/comments.yml+ - The test harness.

First, take a look at +comment.rb+:

<ruby>
class Comment < ActiveRecord::Base
  belongs_to :post
end
</ruby>

This is very similar to the +post.rb+ model that you saw earlier. The difference is the line +belongs_to :post+, which sets up an Active Record _association_. You'll learn a little about associations in the next section of this guide.

In addition to the model, Rails has also made a migration to create the corresponding database table:

<ruby>
class CreateComments < ActiveRecord::Migration
  def self.up
    create_table :comments do |t|
      t.string :commenter
      t.text :body
      t.references :post

      t.timestamps
    end
  end

  def self.down
    drop_table :comments
  end
end
</ruby>

The +t.references+ line sets up a foreign key column for the association between the two models. Go ahead and run the migration:

<shell>
$ rake db:migrate
</shell>

Rails is smart enough to only execute the migrations that have not already been run against the current database, so in this case you will just see:

<shell>
==  CreateComments: migrating =================================================
-- create_table(:comments)
   -> 0.0017s
==  CreateComments: migrated (0.0018s) ========================================
</shell>

h4. Associating Models

Active Record associations let you easily declare the relationship between two models. In the case of comments and posts, you could write out the relationships this way:

* Each comment belongs to one post
* One post can have many comments

In fact, this is very close to the syntax that Rails uses to declare this association. You've already seen the line of code inside the Comment model that makes each comment belong to a Post:

<ruby>
class Comment < ActiveRecord::Base
  belongs_to :post
end
</ruby>

You'll need to edit the +post.rb+ file to add the other side of the association:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }

  has_many :comments
end
</ruby>

These two declarations enable a good bit of automatic behavior. For example, if you have an instance variable +@post+ containing a post, you can retrieve all the comments belonging to that post as the array +@post.comments+.

TIP: For more information on Active Record associations, see the "Active Record Associations":association_basics.html guide.

h4. Adding a Route for Comments

As with the +home+ controller, we will need to add a route so that Rails knows where we would like to navigate to see +comments+.  Open up the +config/routes.rb+ file again, you will see an entry that was added automatically for +posts+ near the top by the scaffold generator, +resources :posts+, edit it as follows:

<ruby>
resources :posts do
  resources :comments
end
</ruby>

This creates +comments+ as a _nested resource_ within +posts+. This is another part of capturing the hierarchical relationship that exists between posts and comments.

TIP: For more information on routing, see the "Rails Routing from the Outside In":routing.html guide.

h4. Generating a Controller

With the model in hand, you can turn your attention to creating a matching controller. Again, there's a generator for this:

<shell>
$ rails generate controller Comments
</shell>

This creates four files and one empty directory:

* +app/controllers/comments_controller.rb+ - The controller
* +app/helpers/comments_helper.rb+ - A view helper file
* +test/functional/comments_controller_test.rb+ - The functional tests for the controller
* +test/unit/helpers/comments_helper_test.rb+ - The unit tests for the helper
* +app/views/comments/+ - Views of the controller are stored here

Like with any blog, our readers will create their comments directly after reading the post, and once they have added their comment, will be sent back to the post show page to see their comment now listed.  Due to this, our +CommentsController+ is there to provide a method to create comments and delete SPAM comments when they arrive.

So first, we'll wire up the Post show template (+/app/views/posts/show.html.erb+) to let us make a new comment:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<h2>Add a comment:</h2>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>

<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

This adds a form on the Post show page that creates a new comment, which will call the +CommentsController+ +create+ action, so let's wire that up:

<ruby>
class CommentsController < ApplicationController
  def create
    @post = Post.find(params[:post_id])
    @comment = @post.comments.create(params[:comment])
    redirect_to post_path(@post)
  end
end
</ruby>

You'll see a bit more complexity here than you did in the controller for posts. That's a side-effect of the nesting that you've set up; each request for a comment has to keep track of the post to which the comment is attached, thus the initial find action to the Post model to get the post in question.

In addition, the code takes advantage of some of the methods available for an association. We use the +create+ method on +@post.comments+ to create and save the comment. This will automatically link the comment so that it belongs to that particular post.

Once we have made the new comment, we send the user back to the original post using the +post_path(@post)+ helper. As we have already seen, this calls the +show+ action of the +PostsController+ which in turn renders the +show.html.erb+ template. This is where we want the comment to show, so let's add that to the +app/views/posts/show.html.erb+.

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<h2>Comments</h2>
<% @post.comments.each do |comment| %>
  <p>
    <b>Commenter:</b>
    <%= comment.commenter %>
  </p>

  <p>
    <b>Comment:</b>
    <%= comment.body %>
  </p>
<% end %>

<h2>Add a comment:</h2>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>

<br />

<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

Now you can add posts and comments to your blog and have them show up in the right places.

h3. Refactoring

Now that we have Posts and Comments working, if we take a look at the +app/views/posts/show.html.erb+ template, it's getting long and awkward. We can use partials to clean this up.

h4. Rendering Partial Collections

First we will make a comment partial to extract showing all the comments for the post. Create the file +app/views/comments/_comment.html.erb+ and put the following into it:

<erb>
<p>
  <b>Commenter:</b>
  <%= comment.commenter %>
</p>

<p>
  <b>Comment:</b>
  <%= comment.body %>
</p>
</erb>

Then in the +app/views/posts/show.html.erb+ you can change it to look like the following:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<h2>Comments</h2>
<%= render @post.comments %>

<h2>Add a comment:</h2>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>

<br />

<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

This will now render the partial in +app/views/comments/_comment.html.erb+ once for each comment that is in the +@post.comments+ collection.  As the +render+ method iterates over the <tt>@post.comments</tt> collection, it assigns each comment to a local variable named the same as the partial, in this case +comment+ which is then available in the partial for us to show.

h4. Rendering a Partial Form

Lets also move that new comment section out to it's own partial, again, you create a file +app/views/comments/_form.html.erb+ and in it you put:

<erb>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>
</erb>

Then you make the +app/views/posts/show.html.erb+ look like the following:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<h2>Comments</h2>
<%= render @post.comments %>

<h2>Add a comment:</h2>
<%= render "comments/form" %>

<br />

<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

The second render just defines the partial template we want to render, <tt>comments/form</tt>, Rails is smart enough to spot the forward slash in that string and realize that you want to render the <tt>_form.html.erb</tt> file in the <tt>app/views/comments</tt> directory.

The +@post+ object is available to any partials rendered in the view because we defined it as an instance variable.

h3. Deleting Comments

Another important feature on a blog is being able to delete SPAM comments.  To do this, we need to implement a link of some sort in the view and a +DELETE+ action in the +CommentsController+.

So first, let's add the delete link in the +app/views/comments/_comment.html.erb+ partial:

<erb>
<p>
  <b>Commenter:</b>
  <%= comment.commenter %>
</p>

<p>
  <b>Comment:</b>
  <%= comment.body %>
</p>

<p>
  <%= link_to 'Destroy Comment', [comment.post, comment],
               :confirm => 'Are you sure?',
               :method => :delete %>
</p>
</erb>

Clicking this new "Destroy Comment" link will fire off a <tt>DELETE /posts/:id/comments/:id</tt> to our +CommentsController+, which can then use this to find the comment we want to delete, so let's add a destroy action to our controller:

<ruby>
class CommentsController < ApplicationController

  def create
    @post = Post.find(params[:post_id])
    @comment = @post.comments.create(params[:comment])
    redirect_to post_path(@post)
  end

  def destroy
    @post = Post.find(params[:post_id])
    @comment = @post.comments.find(params[:id])
    @comment.destroy
    redirect_to post_path(@post)
  end

end
</ruby>

The +destroy+ action will find the post we are looking at, locate the comment within the <tt>@post.comments</tt> collection, and then remove it from the database and send us back to the show action for the post.


h4. Deleting Associated Objects

If you delete a post then its associated comments will also need to be deleted. Otherwise they would simply occupy space in the database. Rails allows you to use the +dependent+ option of an association to achieve this. Modify the Post model, +app/models/post.rb+, as follows:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }
  has_many :comments, :dependent => :destroy
end
</ruby>

h3. Security

If you were to publish your blog online, anybody would be able to add, edit and delete posts or delete comments.

Rails provides a very simple HTTP authentication system that will work nicely in this situation. First, we enable simple HTTP based authentication in our <tt>app/controllers/application_controller.rb</tt>:

<ruby>
class ApplicationController < ActionController::Base
  protect_from_forgery

  private

  def authenticate
    authenticate_or_request_with_http_basic do |user_name, password|
      user_name == 'admin' && password == 'password'
    end
  end

end
</ruby>

You can obviously change the username and password to whatever you want.  We put this method inside of +ApplicationController+ so that it is available to all of our controllers.

Then in the +PostsController+ we need to have a way to block access to the various actions if the person is not authenticated, here we can use the Rails <tt>before_filter</tt> method, which allows us to specify that Rails must run a method and only then allow access to the requested action if that method allows it.

To use the before filter, we specify it at the top of our +PostsController+, in this case, we want the user to be authenticated on every action, except for +index+ and +show+, so we write that:

<ruby>
class PostsController < ApplicationController

  before_filter :authenticate, :except => [:index, :show]

  # GET /posts
  # GET /posts.xml
  def index
    @posts = Post.all
    respond_to do |format|
# snipped for brevity
</ruby>

We also only want to allow authenticated users to delete comments, so in the +CommentsController+ we write:

<ruby>
class CommentsController < ApplicationController

  before_filter :authenticate, :only => :destroy

  def create
    @post = Post.find(params[:post_id])
# snipped for brevity
</ruby>

Now if you try to create a new post, you will be greeted with a basic HTTP Authentication challenge

!images/challenge.png(Basic HTTP Authentication Challenge)!


h3. Building a Multi-Model Form

Another feature of your average blog is the ability to tag posts. To implement this feature your application needs to interact with more than one model on a single form. Rails offers support for nested forms.

To demonstrate this, we will add support for giving each post multiple tags, right in the form where you create the post. First, create a new model to hold the tags:

<shell>
$ rails generate model tag name:string post:references
</shell>

Again, run the migration to create the database table:

<shell>
$ rake db:migrate
</shell>

Next, edit the +post.rb+ file to create the other side of the association, and to tell Rails (via the +accepts_nested_attributes_for+ macro) that you intend to edit tags via posts:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }

  has_many :comments, :dependent => :destroy
  has_many :tags

  accepts_nested_attributes_for :tags, :allow_destroy => :true,
    :reject_if => proc { |attrs| attrs.all? { |k, v| v.blank? } }
end
</ruby>

The +:allow_destroy+ option on the nested attribute declaration tells Rails to display a "remove" checkbox on the view that you'll build shortly. The +:reject_if+ option prevents saving new tags that do not have any attributes filled in.

We will modify +views/posts/_form.html.erb+ to render a partial to make a tag:

<erb>
<% @post.tags.build %>
<%= form_for(@post) do |post_form| %>
  <% if @post.errors.any? %>
  <div id="errorExplanation">
    <h2><%= pluralize(@post.errors.count, "error") %> prohibited this post from being saved:</h2>
    <ul>
    <% @post.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
  <% end %>

  <div class="field">
    <%= post_form.label :name %><br />
    <%= post_form.text_field :name %>
  </div>
  <div class="field">
    <%= post_form.label :title %><br />
    <%= post_form.text_field :title %>
  </div>
  <div class="field">
    <%= post_form.label :content %><br />
    <%= post_form.text_area :content %>
  </div>
  <h2>Tags</h2>
  <%= render :partial => 'tags/form',
             :locals => {:form => post_form} %>
  <div class="actions">
    <%= post_form.submit %>
  </div>
<% end %>
</erb>

Note that we have changed the +f+ in +form_for(@post) do |f|+ to +post_form+ to make it easier to understand what is going on.

This example shows another option of the render helper, being able to pass in local variables, in this case, we want the local variable +form+ in the partial to refer to the +post_form+ object.

We also add a <tt>@post.tags.build</tt> at the top of this form, this is to make sure there is a new tag ready to have it's name filled in by the user.  If you do not build the new tag, then the form will not appear as there is no new Tag object ready to create.

Now create the folder <tt>app/views/tags</tt> and make a file in there called <tt>_form.html.erb</tt> which contains the form for the tag:

<erb>
<%= form.fields_for :tags do |tag_form| %>
  <div class="field">
    <%= tag_form.label :name, 'Tag:' %>
    <%= tag_form.text_field :name %>
  </div>
  <% unless tag_form.object.nil? || tag_form.object.new_record? %>
    <div class="field">
      <%= tag_form.label :_destroy, 'Remove:' %>
      <%= tag_form.check_box :_destroy %>
    </div>
  <% end %>
<% end %>
</erb>

Finally, we will edit the <tt>app/views/posts/show.html.erb</tt> template to show our tags.

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<p>
  <b>Tags:</b>
  <%= @post.tags.map { |t| t.name }.join(", ") %>
</p>

<h2>Comments</h2>
<%= render @post.comments %>

<h2>Add a comment:</h2>
<%= render "comments/form" %>


<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

With these changes in place, you'll find that you can edit a post and its tags directly on the same view.

However, that method call <tt>@post.tags.map { |t| t.name }.join(", ")</tt> is awkward, we could handle this by making a helper method.

h3. View Helpers

View Helpers live in <tt>app/helpers</tt> and provide small snippets of reusable code for views.  In our case, we want a method that strings a bunch of objects together using their name attribute and joining them with a comma.  As this is for the Post show template, we put it in the PostsHelper.

Open up <tt>app/helpers/posts_helper.rb</tt> and add the following:

<erb>
module PostsHelper
  def join_tags(post)
    post.tags.map { |t| t.name }.join(", ")
  end
end
</erb>

Now you can edit the view in <tt>app/views/posts/show.html.erb</tt> to look like this:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<p>
  <b>Tags:</b>
  <%= join_tags(@post) %>
</p>

<h2>Comments</h2>
<%= render @post.comments %>

<h2>Add a comment:</h2>
<%= render "comments/form" %>


<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

h3. What's Next?

Now that you've seen your first Rails application, you should feel free to update it and experiment on your own. But you don't have to do everything without help. As you need assistance getting up and running with Rails, feel free to consult these support resources:

* The "Ruby on Rails guides":index.html
* The "Ruby on Rails Tutorial":http://railstutorial.org/book
* The "Ruby on Rails mailing list":http://groups.google.com/group/rubyonrails-talk
* The "#rubyonrails":irc://irc.freenode.net/#rubyonrails channel on irc.freenode.net
* The "Rails Wiki":http://wiki.rubyonrails.org/

Rails also comes with built-in help that you can generate using the rake command-line utility:

* Running +rake doc:guides+ will put a full copy of the Rails Guides in the +doc/guides+ folder of your application. Open +doc/guides/index.html+ in your web browser to explore the Guides.
* Running +rake doc:rails+ will put a full copy of the API documentation for Rails in the +doc/api+ folder of your application. Open +doc/api/index.html+ in your web browser to explore the API documentation.

h3. Configuration Gotchas

The easiest way to work with Rails is to store all external data as UTF-8. If you don't, Ruby libraries and Rails will often be able to convert your native data into UTF-8, but this doesn't always work reliably, so you're better off ensuring that all external data is UTF-8.

If you have made a mistake in this area, the most common symptom is a black diamond with a question mark inside appearing in the browser. Another common symptom is characters like "Ã¼" appearing instead of "ü". Rails takes a number of internal steps to mitigate common causes of these problems that can be automatically detected and corrected. However, if you have external data that is not stored as UTF-8, it can occasionally result in these kinds of issues that cannot be automatically detected by Rails and corrected.

Two very common sources of data that are not UTF-8:
* Your text editor: Most text editors (such as Textmate), default to saving files as
  UTF-8. If your text editor does not, this can result in special characters that you
  enter in your templates (such as é) to appear as a diamond with a question mark inside
  in the browser. This also applies to your I18N translation files.
  Most editors that do not already default to UTF-8 (such as some versions of
  Dreamweaver) offer a way to change the default to UTF-8. Do so.
* Your database. Rails defaults to converting data from your database into UTF-8 at
  the boundary. However, if your database is not using UTF-8 internally, it may not
  be able to store all characters that your users enter. For instance, if your database
  is using Latin-1 internally, and your user enters a Russian, Hebrew, or Japanese
  character, the data will be lost forever once it enters the database. If possible,
  use UTF-8 as the internal storage of your database.

h3. Changelog

* August 30, 2010: Minor editing after Rails 3 release by "Joost Baaij":http://www.spacebabies.nl
* July 12, 2010: Fixes, editing and updating of code samples by "Jaime Iniesta":http://jaimeiniesta.com
* May 16, 2010: Added a section on configuration gotchas to address common encoding problems that people might have by "Yehuda Katz":http://www.yehudakatz.com
* April 30, 2010: Fixes, editing and updating of code samples by "Rohit Arondekar":http://rohitarondekar.com
* April 25, 2010: Couple of more minor fixups "Mikel Lindsaar":credits.html#raasdnil
* April 1, 2010: Fixed document to validate XHTML 1.0 Strict. "Jaime Iniesta":http://jaimeiniesta.com
* February 8, 2010: Full re-write for Rails 3.0-beta, added helpers and before_filters, refactored code by "Mikel Lindsaar":credits.html#raasdnil
* January 24, 2010: Re-write for Rails 3.0 by "Mikel Lindsaar":credits.html#raasdnil
* July 18, 2009: Minor cleanup in anticipation of Rails 2.3.3 by "Mike Gunderloy":credits.html#mgunderloy
* February 1, 2009: Updated for Rails 2.3 by "Mike Gunderloy":credits.html#mgunderloy
* November 3, 2008: Formatting patch from Dave Rothlisberger
* November 1, 2008: First approved version by "Mike Gunderloy":credits.html#mgunderloy
* October 16, 2008: Revised based on feedback from Pratik Naik by "Mike Gunderloy":credits.html#mgunderloy (not yet approved for publication)
* October 13, 2008: First complete draft by "Mike Gunderloy":credits.html#mgunderloy (not yet approved for publication)
* October 12, 2008: More detail, rearrangement, editing by "Mike Gunderloy":credits.html#mgunderloy (not yet approved for publication)
* September 8, 2008: initial version by "James Miller":credits.html#bensie (not yet approved for publication)
