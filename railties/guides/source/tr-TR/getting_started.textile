h2. Rails'e Başlamak

Bu klavuz Ruby on Rails'i kurmanız ve çalıştırmanız için gerekenleri içerir. Onu okuduktan sonra şu konularda bilgi sahibi olacaksınız:

* Rails Kurulumu, yeni bir Rails uygulaması üretimi ve uygulamanızın bir veritabanına bağlantısı
* Bir Rails uygulamasının genel yapısı
* MVC (Model, View Controller) ve RESTful tasarımın temel prensipleri
* Bir Rails uygulamasının başlangıç kısımlarını nasıl çabukça üretirsiniz.

endprologue.

UYARI. Bu klavuz Rails 3.0 a göre düzenlenmiştir. Burada gösterilen bazı kodlar önceki Rails versiyonlarında çalışmaz.

h3. Klavuzun Varsayımları

Bu klavuz Rails'e sıfırdan başlamak isteyen yeni programcılar için düzenlenmiştir. Daha önceden herhangi bir Rails bilginiz olmasını beklemez. Ancak, başlamadan önce şu bileşenlerin kurulu olması gerekir:

* "Ruby":http://www.ruby-lang.org/en/downloads programlama dili versiyon 1.8.7 ya da daha yüksek olmalı

İPUCU: Ruby 1.8.7 p248 ve p249 Rails 3.0'ın çakılmasına neden olan bug'lar içeriyordu. Ruby Enterprise Edition release 1.8.7-2010.02 den itibaren bu düzeltildi. Ruby 1.9.1 ise Rails 3.0'da segfault hataları veriyor, o yüzden 1.9.x serisiyle Rails 3.0 kullanmak isterseniz Ruby 1.9.2 den itibaren kullanın.

* "RubyGems":http://rubyforge.org/frs/?group_id=126 paketleme sistemi
* Çalışan bir "SQLite3 Veritabanı":http://www.sqlite.org

Rails, Ruby programlama dili üzerinden çalışan bir web uygulama geliştirme iskeletidir. Eğer Ruby hakkında önceden bilginiz yoksa, Rails öğrenirken zorlanacaksınız. Ruby öğrenmek için birçok bedava kaynak vardır, bazıları şunlar:

* "Mr. Neighborly's Humble Little Ruby Book":http://www.humblelittlerubybook.com
* "Programming Ruby":http://www.ruby-doc.org/docs/ProgrammingRuby/
* "Why's (Poignant) Guide to Ruby":http://mislav.uniqpath.com/poignant-guide/

h3. Rails Nedir?

Rails, Ruby programlama dili üzerinden çalışan bir web uygulama geliştirme iskeletidir. Her geliştiricinin başlarken ihtiyaç duyacağı şeyler hakkında varsayımlarda bulunarak web uygulamalarının yapılmasını kolaylaştırmak için tasarlanmıştır. Diğer benzerlerinden çok daha az kod yazarak başarıya ulaşmanızı sağlar. Uzmanlaşmış Rails kullanıcıları web uygulaması geliştirmenin eğlenceli hale getirildiğini de söyler.

Rails dikkafalı bir yazılımdır. Birşeyleri yapmanın en iyi yolu olduğunu ve kendisinin bu yolu kullandığını savunur ve bazen diğer yolları da inkar eder. Eğer "Rails yolu"nu öğrenirseniz, yüksek ihtimalle üretkenliğinizde büyük bir atış olduğunu göreceksiniz. Eğer daha önceki tecrübelerinizden yada bildiğiniz dillerden birşeyleri uygulamaya kalkarsanız daha başarısız olursunuz.

Rails filozofisi birkaç temel üzerine oturmuştur :

* DRY - "Dont Repeat Yourself (kendini tekrar edip durma)" - Aynı kodu tekrar tekrar yazmanın kötü birşey olduğunu savunur.
* Convention Over Configuration - Konfigürasyon kuralları koyar. Rails sizin na yapacağınıza ve nasıl yapacağınıza dair varsayımlarda bulunarak her küçük ayrıntıyı sayısız defa ayarlamanızı engeller.
* REST kaynaklarınızı ve standart HTTP işlerini en hızlı ilerlenecek şekilde ayarlayan bir web uygulama düzenidir.

h4. MVC Mimarisi

Rails'in merkezi Model, View, Controller mimarisidir, genellikle MVC diye çağrılır. MVC'nin avantajları şunlar :

* Kullanıcı arabirimi ile iş yapan lojiği biribrinden ayırır.
* DRY prensiplerine bağlı kalmayı kolaylaştırır.
* Farklı tiplerde kodlamaların berraklığı sayesinde bakım ve modifikasyon kolaylaşır.

h5. Modeller

Bir model, uygulama ve verileri arasındaki işlemleri sağlar. Rails yapısında modeller esas olarak bağlı veritabanı ile iletişimin kurallarını yönetir. Birçok durumda veri tabanınızdaki her tabloya karşı uygulamanızda bir model olacaktır. Uygulamanızın arkaplandaki lojiği çoğunlukla bu modeller üzerinde işlem yapacaktır.

h5. View'lar (Görseller)

Görseller uygulamanızın kullanıcı arabirimini oluştururlar. Rails'de görseller, genellikle görevleri veriyi sunmak olan ruby kodlarıyla birleştirilmiş HTML dosyalarıdır. Görseller internet tarayıcılarında verileri göstermek veya uygulamanızdan yapılacak istekleri iletmede kullanılır.

h5. Controller'lar 

Kontrolörler, modeller ve görseller arasında birleştirici görevi yaparlar. Rails'de kontrolörler, webten gelen istekleri işlemekle, modelleri veri için sorgulamakla ve verileri kullanıcıya sunulması için görsellere iletmekle sorumludurlar.

h4. Rails'in Bileşenleri

Rails, birçok özgün bileşenle birlikte gelir.

* Action Pack
  ** Action Controller
  ** Action Dispatch
  ** Action View
* Action Mailer
* Active Model
* Active Record
* Active Resource
* Active Support
* Railties


h5. Action Pack (Eylem Paketi)

Action Pack içinde Action Controller, Action View ve Action Dispatch bileşenlerinden oluşan tek bir gem'dir. MVC'nin VC parçasını oluşturur.

h5. Action Controller (kontrolör eylemleri)

Action Controller, bir Rails uygulamasında kontrolörleri yönetir. Action Controller, Rails uygulamasına gelen istekleri işleyerek parametreleri ayırır ve onları ilgili eylemlere dağıtır. Action Controller tarafından sağlanan servisler içinde oturum yönetimi, görsel kalıpların yayınlanması ve yönlendirmeler vardır.

h5. Action View (görsel eylemleri)

Action View, Rails uygulamanızdaki görselleri yönetir. Default olarak HTML ve XML çıktı üretebilir. Action View, görsel kalıpları yönetir. Bunlar içinde içiçe kalıpların işlenmesi ve Ajax desteği de vardır.

h5. Action Dispatch (dağıtım eylemleri)

Action Dispatch, gelen web isteklerinin yönlendirilmesini yönetir ve istediğiniz şekilde sizin uygulamanıza veya diğer bir Rack uygulamasına dağıtımını sağlar. 

h5. Action Mailer

Action Mailer, e-mail servisleri üretmek için bir iskelettir. Action Mailer'ı gelen mailleri işlemekte ve basit bir yazıdan birçok kalıplarda komplex e-maillere kadar mail hazırlayıp göndermede kullanabilirsiniz.

h5. Active Model

Active Model, Action Pack gem servisleri ve Active Record gibi obje ilişkileri yönlendirme gemleri arasında bir bağlaşım sağlar. Active Model ile Active Record yerine eğer uygulmanızın ihtiyacı varsa diğer ORM iskeletleri de kullanabilirsiniz.

h5. Active Record

Active Record bir Rails uygulamasında modeller için temeldir. Veri tabanından bağımsız olmayı, basit CRUD işlevlerini ve modellerin bir diğerleriyle ilişkisini sağlar.

h5. Active Resource

Active Resource, işlevsel nesnelerle REST temelli web servisleri arasında bağlantı sağlayan bir iskelet sağlar. CRUD mantığıyla web temelli kaynaklar ve yerel nesneler arasında bir yol çizer.

h5. Active Support

Active Support, Rails uygulamaları için yazılmış, hem merkezde hem uygulamanızda kullanılan gelişmiş birçok Ruby kütüphane ilaveleri içerir.

h5. Railties

Railties yeni bir Rails uygulaması için kod üretmekte ve değişik iskeletlerle plugin'leri Rails uygulamasında içermek için kullanılan merkez ünitedir.

h4. REST

Rest, Representational State Transfer cümlesini ifade eder ve RESTfull mimarisinin temelidir. Bu Roy Fielding'in ağ temelli yazılım mimarileri ve stillerini belirten doktora tezinden esinlenmiştir. Bu teze göre Rails uygulamasına şu ana özellikler kazandırılmıştır :

* Kaynakları gösteren URL ler benzeri kaynak imleri kullanmak.
* Sistem bileşenleri arasında kaynakların durumunu taşımak.

Örneğin Bir Rails uygulamasına şöyle bir istek gelsin :

<tt>DELETE /photos/17</tt>

 yazımından anlaşılacağı gibi id'si 17 olan bir fotoğrafın silinmesi isteğidir. REST web uygulamaları için doğal bir yöntemdir ve Rails bunu yöneterek sizi birçok karmaşık işten ve tarayıcı süprizlerinden kurtarır.

Eğer REST yapısı hakkında ve Fielding'in tezi hakkında daha fazla bilgi sahibi olmak isterseniz bu kaynaklara bakabilirsiniz :

* "A Brief Introduction to REST":http://www.infoq.com/articles/rest-introduction by Stefan Tilkov
* "An Introduction to REST":http://bitworking.org/news/373/An-Introduction-to-REST (video tutorial) by Joe Gregorio
* "Representational State Transfer":http://en.wikipedia.org/wiki/Representational_State_Transfer article in Wikipedia
* "How to GET a Cup of Coffee":http://www.infoq.com/articles/webber-rest-workflow by Jim Webber, Savas Parastatidis & Ian Robinson

h3. Yeni Bir Rails Projesi Üretmek

Eğer bu klavuzu takip ederseniz, <tt>blog</tt> adında bir Rails uygulaması üreteceksiniz, çok basit bir web günlüğü. Uygulamayı inşa etmeye başlamadan önce, Rails'in sisteminizde kurulu olduğundan emin olmalısınız.

h4. Rails Kurulumu

Birçok durumda, Rails kurmanın en kolay yolu RubyGems avantajını kullanmak olacaktır:

<shell>
Genellikle bu komutu root kullanıcı olarak çalıştırmanız gerekir: 
# gem install rails
</shell>

İPUCU. Eğer Windows kullanıyorsanız, Instant Rails'in kurulumunu daha basit bulacaksınız. Gerçi Instant Rails en son versiyondan genelde geride kalıyor ama. Ayrıca windos üzerinde Rails geliştirme yapmak diğer sistemlere nazaran daha keyifsizdir. Eğer mümkünse tavsiyemiz windows yerine bir Linux sanal makina yardımıyla Rails çalışmanızdır.

h4. Blog Uygulmasını Üretmek

Bu klavuzu kullanmanın en iyi yolu sırası geldiğinde her adımı takip etmek, bu örneği yapmak için gereken hiçbir kodlama dışarda bırakılmamıştır. Bu yüzden adım adım izleyebilirsiniz. Eğer bitmiş kodu görmek isterseniz, "Getting Started Code":http://github.com/mikel/getting-started-code dan indirebilirsiniz.

Başlamak için bir konsol (terminal) açın ve uygulamanızı koymak istediğiniz ve dosya yazma hakkınızın bulunduğu bir klasöre gidin ve şunu yazın:

<shell>
$ rails new blog
</shell>

Bu "blog" adlı klasör içinde Blog ismi verilen bir uygulama üretecektir.

İPUCU: Rails Uygulama Üretecinin tüm komut satır parametrelerini <tt>rails -h</tt> komutuyla görebilirsiniz.

Uygulamanın üretilmesini hata mesajı almadan birçok dosya oluşturulmasından gördükten sonra uygulamanın bulunduğu klasöre geçin:

<shell>
$ cd blog
</shell>

Rails blog adında bir klasör oluşturdu. Bu klasörü açın ve inceleyin. Bu tutorial'de çoğunlukla "app" klasöründe çalışılacak fakat Rails'in ürettiği klasörlerde basit bir gezinti yapalım:

|_.Dosya/Klasör|_.Amacı|
|Gemfile| Bu dosya Rails uygulamanızın hangi Gem'lere bağlantılı olduğunu belirtir.|
|README|README dosyası uygulamanız hakkında kısa bilgi bulundurmalıdır. Onda uygulamanızın ne iş yaptığını, nasıl ayarlandığını vb. bilgileri bulundurmalısınız.|
|Rakefile|Bu dosyada terminalden çalıştırılabilen batch işler bulunur.|
|app/|Bu klasörde uygulamanızın kontrolör ve görselleri bulunur. Bu klavuzun geri kalan kısmında bu klasöre yoğunlaşacaksınız.|
|config/|uygulamanızın çalışma kuralları. yönlendirmeleri, ve veritabanı ayarlamaları vs. bu klasördedir.|
|config.ru|Rack temelli serverlar için uygulamayı başlatma konfigürasyonları.|
|db/|Veritabanınızın yapısını barındırır. Ayrıca veritabanı birleştirmelerini (Migration) içerir. Birleştirmeleri ilerde göreceksiniz.|
|doc/|Uygulamanızın dokümanları bu klasördedir.|
|lib/|Uygulamanızın genişlemesi için modüller buradadır. (bu klavuzda anlatılmamıştır).|
|log/|Uygulamanın log dosyaları.|
|public/|Dış dünyadan olduğu şekliyle ulaşılabilen yegane dosyalar buradadır. Burada tüm resimleriniz, javascriptleriniz, stilleriniz ve diğer sunacağınız dosyalar bulunur.|
|script/|Uygulamanızı çalıştırmak ve yükleme ve diğer çalışma işlevlerinin script'leri içeren klasör.|
|test/|Test işlemleri , bağlayıcılar ve diğer test yardımcıları buradadır. Bu konular "Rails uygulamasının test edilmesi":testing.html bölümünde işlenecek.|
|tmp/|Geçici dosyalar|
|vendor/|Tüm 3. parti yazılımları buradadır. Tipik bir Rails uygulamasında, Gem dosyaları, pluginler ve projenizin içine gömecekseniz Rails kaynak kodu bulunur.|

h4. Gerekli Gemlerin Kurulması

Rails uygulamanızın kullandığı tüm gemleri vendor klasöründe işlemek için "Bundler":http://gembundler.com/v1.0/index.html gemi kullanır. Default olan dışında özel bir gem kullanmayacağımız için sadece şunu yapmamız gerekiyor:

<shell>
# bundle install
</shell>

h4. Bir Veritabanı Tanıtmak

Hemen tüm Rails uygulamaları bir veritabanı kullanır. Kullanılacak veritabanı +config/database.yml+ dosyasında tarif edilir. 
Eğer yeni bir Rails uygulamasında bu dosyayı açarsanız SQLITE3 bir veritabanı tarif edildiğini görürsünüz. Bu dosyada Railsin kullandığı 3 değişik ortama ait kısımlar vardır:

* +Development+ (geliştirme) ortamı uygulamanızı geliştirirken manual iletişim kurabileceğiniz ortamdır.
* +Test+ ortamı uygulamanın otomatize testlerini çalıştırabileceğiniz ortamdır.
* +Production+ (üretim) ortamı uygulamanızı dünyanın kullanımı için yayınlamanızda kullanılır.

h5. Bir SQLite3 veritabanı düzenlemek

Rails, hafif server'sız bir veritabanı olan SQLite3 desteği ile gelir. Çok çalışan uygulamalar SQLite3 veritabanını zorlasa da geliştirme ortamı için idealdir. Rails yeni bir uygulama başlattığında SQLite3 olarak yapılanır ama istediğiniz zaman değiştirebilirsiniz.

Bunlar geliştirme ortamı bölümü için (<tt>config/database</tt>) dosyasının default yapılandırması :

<yaml>
development:
  adapter: sqlite3
  database: db/development.sqlite3
  pool: 5
  timeout: 5000
</yaml>

NOTE: Bu klavuzda verilerimizi saklamak için bir SQLite3 veritabanı kullanıyoruz, bu yüzden veritabanı konfigürasyon dosyasında bir değişiklik yapmamıza gerek yok. Rails ayrıca MySQL ve PrstgreSQL destekler ve diğer birçok veritabanları için plugin'leri  vardır. Eğer halihazırda kullandığınız bir veritabanı varsa Rails'in yüksek ihtimalle ona uygun bir adaptörü vardır.

h5. MySQL Veritabanı Konfigürasyonu

Eğer birlikte gelen SQLite3 veritabanı yerine MySQL kullanmayı tercih ederseniz, database.yml dosyanız farklı olmalıdır. İşte geliştirme ortamı bölümü:

<yaml>
development:
  adapter: mysql2
  encoding: utf8
  database: blog_development
  pool: 5
  username: root
  password:
  socket: /tmp/mysql.sock
</yaml>

Eğer geliştirme yatığınız bilgisayardaki MySQL server root kullanıcısı boş şifreyle çalışıyorsa bu konfigürasyon çalışacaktır. Aksi halde kullanıcı adı ve şifrenin server kullanıcısına uygun şekilde değiştirilmesi gerekir.

h5. PostgreSQL veritabanı konfigürasyonu

Son olarak, eğer PostgreSQL veritabanı kullanmayı tercih ederseniz "config/database.yml" dosyanız buna göre ayarlanmalıdır:

<yaml>
development:
  adapter: postgresql
  encoding: unicode
  database: blog_development
  pool: 5
  username: blog
  password:
</yaml>

Kullanıcı adı ve şifreyi doğru şekilde değiştirin.

h4. Veritabanı Oluşturulması

Şu anda veritabanı konfigürasyonunuz tamam, şimdi Rails'in sizin için boş bir veritabanı üretmesinin zamanı. Bunu şu komutu girerek yapabilirsiniz:

<shell>
$ rake db:create
</shell>

Bu komut <tt>db/</tt> klasöründe geliştirme ve test veritabanlarınızı oluşturur.

İPUCU: Rake komutu Rails'in birçok şey için kullandığı genel amaçlı bir kod çalıştırıcıdır. Olası komutları +rake -T+ komutu girerek görebilirsiniz.

h3. Merhaba Rails!

Yeni bir dile başlamanın klasik yolu ekrana yazılı birşeyler getirmektir. Rails'de bunun olması için uygulama server'ı çalıştırmalısınız.

h4. Web Server'ı Çalıştırmak

Aslında şu ana kadar yaptıklarınızla aktif bir Rails uygulamanız hazır. Bunu görmek için geliştirme makinenizde web server'ı başlatmanız gerekiyor:

<shell>
$ rails server
</shell>

Bu default olarak bir Mongrel web server başlatacaktır.(Rails diğer farklı server'lar da kullanabilir, mesela mongrel yoksa otomatikman webrick çalışır). Uygulamanızı çalışır şekilde görmek için bir tarayıcı açın ve "http://localhost:3000":http://localhost:3000 adresini girin. Rails'in default bilgilendirme ekranı gelecektir:

!images/rails_welcome.png(Welcome Aboard screenshot)!

İPUCU: Web server'ı durdurmak için çalıştırdığınız konsol ekranında Ctrl+C basmanız gerekir. Geliştirme modunda, genellikle Rails server'ı durdurmanız gerekmez; dosyalarda yaptığınız değişiklikler server'a otomatik yüklenecektir.

“Welcome Aboard” yeni bir Rails uygulamasının tüten buharıdır: uygulamanızın server'dan yayınlanması için herşeyn uygun olduğundan emin olmak içindir. Ayrıca _About your application’s environment_ bağlantısına tıklayarak uygulamanızın kullandığı ortam hakkında bilgi edinebilirsiniz.

h4. "Merhaba" de Rails

Railsin "Merhaba" demesi için, en az bir kontrolör ve bir görsel ihtiyacınız vardır. Çok şükür ki bunu tek komutla yapabilirsiniz. Şu komutu terminalden girin:

<shell>
$ rails generate controller home index
</shell>

İPUCU: Eğer Windows'taysanız yada Ruby kurulumunuz standart olmayan bir kurulumdaysa Ruby'ye rails komutunun yolunu da net olarak belirtmeniz gerekir: +ruby \path\to\rails generate controller home index+.

Rails sizin için bazı dosyalar üretecektir. Biri de +app/views/home/index.html.erb+. Bu +home+ kontrolörünün +index+ eylemi sayfasını göstermekte kullanılacak olan kalıp dosyadır. Bu dosyayı editörde açıp içine sadece şu satırı koyun gerisini silin:

<code class="html">
<h1>Merhaba Rails!</h1>
</code>

h4. Uygulamanın Ana Sayfasının Ayarlanması

Şimdiye kadar kontrolör ve görsel dosyasını hazırladık, Rails'e "Merhaba Rails" mesajını görmek istediğimizi anlatmalıyız. Bu durumda "http://localhost:3000":http://localhost:3000 adresi girince "Welcome Aboard" yerine hazırladığımız görselin çıkmasını istiyoruz.

Bunu yapmanın ilk adımı uygulamanın default sayfasını silmek:

<shell>
$ rm public/index.html
</shell>

Rails yayınlama yaparken +public+ klasöründeki statik dosyaları bizim kontrolörle ürettiğimiz dinamik dosyalara tercih edeceği için bunu yapmamız gerekir.

Şimdi Rails'e gerçek ana sayfanın nerede olduğunu anlamanız gerekiyor. +config/routes.rb+ dosyasını editörde açın. Bu uygulamanızın Rails'e gelen çağrılarını nasıl yönlendireceğini anlatan DSL(Domain Spesific Language) girdileri olan yönlendirme dosyasıdır. Bu dosyada başta sadece yorumlar vardır, bu yorumlarda örnek yönlendirmeler vardır. +root :to+ ile başlayan satırın yorum tikini kaldırın ve şu hale getirin:

<ruby>
Blog::Application.routes.draw do

  #...
  # You can have the root of your site routed with "root"
  # just remember to delete public/index.html.
  root :to => "home#index"
</ruby>

+root :to => "home#index"+ satırı Rails'e root eylemini "home" kontrolörü "index" eylemine yönlendirmesini anlatır. 

Eğer şimdi "http://localhost:3000":http://localhost:3000 adresine gidersek +Merhaba Rails!+ mesajını görebiliriz. 

NOT. Daha fazla bilgi için "Rails Routing from the Outside In":routing.html adresine bakınız.

h3. Scaffolding ile hızlı hazırlık ve çalıştırma.

Rails _Scaffolding_ uygulamanın ana parçalarının üretilmesi için hızlı bir yoldur. Modeller, görseller ve kontrolörleri bir kerede üretmek isterseniz scaffolding size gereken araçtır.

h3. Bir Kaynak Üretmek

Blog uygulamasına göre gönderilerin kaydedileceği bir "Post" kaynağı üreterek başlamak gerekir: bu bir tane blog gönderisi barındıracaktır. Bunu yapmak için konsoldan şu komutu girin:

<shell>
$ rails generate scaffold Post name:string title:string content:text
</shell>

NOT. Scaffolding'in kendi doğrultusunda hazırladığı kodu sizin tercihlerinize uymayabilir. Çoğunlukla ürettiği kodları değiştirmek gerekecektir. Uzmanlık kazanmış programcılar genellikle kodlarını baştan kendileri üretir. Ama başlangıç seviyesi için gereklidir.

Scaffold jeneratör uygulamanıza 15 dosya üretir, bazı klasörler üretir ve bazılarını da edit eder. Şimdi bunlara kısaca bakalım:

|_.Dosya                                       |_.Amacı|
|db/migrate/20100207214725_create_posts.rb    |Veritabanınızda posts tablosunu üretmek için birleştirme dosyasıdır. Dosya isminde üretildiği anın tarihi olduğu için sizin dosyanızın ismi değişik olacaktır.|
|app/models/post.rb                           |"Post" modelinin dosyası|
|test/fixtures/posts.yml                      |Test amaçlı hazırlanmış sahte gönderi verileri|
|app/controllers/posts_controller.rb          |Gönderilerin kontrolör dosyası|
|app/views/posts/index.html.erb               |Tüm gönderilerin yer aldığı görsel dosyası |
|app/views/posts/edit.html.erb                |Bir gönderiyi düzenlemek için görsel sayfası|
|app/views/posts/show.html.erb                |Birtek gönderiyi göstermek için görsel dosyası|
|app/views/posts/new.html.erb                 |Yeni bir gönderi hazırlama görseli|
|app/views/posts/_form.html.erb               |Hem edit hem new eyleminde kullanılan form görüntüsü parçası|
|app/helpers/posts_helper.rb                  |Post görsellerinde kullanmak için yardımcı fonksiyonlar|
|test/unit/post_test.rb                       |Gönderilerin modeli (posts) için birim test kalıbı|
|test/functional/posts_controller_test.rb     |Gönderilerin kontrolörü için fonksiyonel test kalıbı|
|test/unit/helpers/posts_helper_test.rb       |Yardımcılar için test kalıbı|
|config/routes.rb                             |Gönderiler için yönlendirmeler amacıyla düzenlendi|
|public/stylesheets/scaffold.css              |Scaffold ile hazırlanan görseller için hazırlanmış CSS dosyası|

h4. Veritabanı Birleştirme Yapılması (Migration)

+rails generate scaffold+ komutunun ürünlerinden biri de _veritabanı birleştirmesi_ dir. Birleştirmeler (Migration) veritabanı tablolarının üretilmesi ve değiştirilmesini basitleştirmek için kullanılan Ruby sınıflarıdır. Rails birleştirmeler için rake komutunu kullanır, ve bir birleştirme uygulandıktan sonra geri alınabilir. Birleştirme dosyaları, hangi sırada yapıldıklarından emin olmak için yapıldıkları zamanın kodunu içerirler.

Eğer +db/migrate/20100207214725_create_posts.rb+ dosyasının içine bakarsanız (hatırlayın, sizinkinin ismi farklı olacaktır), şunları bulursunuz:

<ruby>
class CreatePosts < ActiveRecord::Migration
  def self.up
    create_table :posts do |t|
      t.string :name
      t.string :title
      t.text :content

      t.timestamps
    end
  end

  def self.down
    drop_table :posts
  end
end
</ruby>

Yukardaki birleştirme iki metod üretir, +up+ bu birlştirmeyi çalıştırdığınızda aktif olur ve +down+ ilerde birleştirmeleri geri almak isterseniz çalışır. Bu görüntüde +up+ komutu +posts+ tablosunu iki string ve bir text sütunu ile oluşturur. Ayrıca kayıtların üretildiği ve update edildiği tarihler için de timestamp alanları üretir. Rails birleştirmeleri hakkında daha fazla bilgi "Rails Database Migrations":migrations.html klavuzunda bulunabilir.

Şimdi birleştirmenin gerçekleşmesi için rake komutu çalıştırın:

<shell>
$ rake db:migrate
</shell>

Rails birleştirme komutunu işletecek ve size +posts+ tablosunu ürettiğini bildirecektir.

<shell>
==  CreatePosts: migrating ====================================================
-- create_table(:posts)
   -> 0.0019s
==  CreatePosts: migrated (0.0020s) ===========================================
</shell>

NOT. Şu anda geliştirme ortamında çalıştığınız için bu komut +config/database.yml+ dosyasının +development+ kısmında belirtilen veritabanında işlem yapacaktır.

h4. Bir Bağlantı Eklemek

Önceden ürettiğiniz ana sayfaya gönderilere gitmek için bir bağlantı ekleyebilirsiniz. +app/views/home/index.html.erb+ dosyasını açın ve şöyle değiştirin:

<code lang="ruby">
<h1>Merhaba Rails!</h1>
<%= link_to "Bloğum", posts_path %>
</code>

+link_to+ metodu Rails'in içerdiği görsel yardımcılarından biridir. Yazılacak yazı ve gidilecek yer parametrelerinden bir hyperlink oluşturur - bu durumda gönderilere bağlantı kurulmuş.

h4. Tarayıcıda Gönderileri Çalışmak

Şimdi gönderilerle çalışmaya başlayabilirsiniz. Bunu yapmak için "http://localhost:3000":http://localhost:3000/ adresine gidin ve "Bloğum" linkini tıklayın:

!images/posts_index.png(Posts Index screenshot)!

Bu gönderilerin +index+ görsel sayfası için Rails'in sunusu sonucudur. Henüz veritabanında herhangibir gönderi yoktur, fakat +New Post+ bağlantısına tıklarsanız yeni bir tane üretebilirsiniz. Bundan sonra gönderileri düzenleyebilir, ayrıntılarını inceleyebilir ve silebilirsiniz. Tüm bu HTML ve lojik tek bir satır +rails generate scaffold+ komutuyla üretildi.

İPUCU: Geliştirme modunda (default olarak bu modda çalışmaktasınız) Rails her tarayıcı isteğinde sayfaları tekrar yükler bu yüzden web server'ın kapatılıp açılmasına gerek yoktur.

Tebrikler, Rails'i kullanmaya başladınız! Şimdi hepsinin nasıl çalıştığını göreceksiniz.

h4. Model

+app/models/post.rb+ model dosyası şu anda çok basit:

<ruby>
class Post < ActiveRecord::Base
end
</ruby>

Bu haliyle söylanacak pek birşey yok - sadece +Post+ sınıfı +ActiveRecord::Base+ sınıfından türetilmiştir. Active Record Rails modellerine bedavaya birçok hizmet sunar. Basit veritabanı CRUD (Create, Read, Update, Destroy) işlemleri, veri denetlemeleri, karmaşık sorgu işlemleri ve birçok modelin diğer biriyle bağlanması gibi.

h4. Bazı Veri Denetimleri Eklenmesi

Rails, modellere gönderdiğiniz veriler üzerinde denetleme yapan metodlar içerir. +app/models/post.rb+ dosyasnı açın ve şöyle düzenleyin:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }
end
</ruby>

Bu değişiklikler, tüm gönderilerin ismi ve etiketi olmasını garanti eder ve etiketin en az 5 karakter uzunluğunda olmasını garanti eder. Rails bir model üzerinde değişik koşulları denetleyebilir. Sütun verilerinin varlığı, benzersizliği, düzeni ve bağlı objelerin varlığı.

h4. Konsolun Kullanımı

Denetlemelerinizin çalışmasını görmek için konsolu kullanabilirsiniz. Konsol uygulamanızın içinde Ruby kodu çalıştırabileceğiniz bir komut satırı aracıdır:

<shell>
$ rails console
</shell>

Konsol yüklendikten sonra, onu uygulamanızın modelleri ile çalışmak için kullanabilirsiniz:

<shell>
>> p = Post.new(:content => "Yeni bir gönderi")
=> #<Post id: nil, name: nil, title: nil,
     content: "A new post", created_at: nil,
     updated_at: nil>
>> p.save
=> false
>> p.errors
=> #<OrderedHash { :title=>["can't be blank",
                           "is too short (minimum is 5 characters)"],
                   :name=>["can't be blank"] }>
</shell>

Bu kod yeni bir +Post+ örneği oluşturulduğunu, kaydetmeye kalkınca +false+ cevabı alındığını (ki bu kayıt işleminin gerçekleşmediğini gösterir) ve gönderi verisindeki hatayı +errors+ ile görmeyi gösteriyor.

Bitirdiğinizde +exit+ yazın ve +return+ basarak konsoldan çıkabilirsiniz.

İPUCU: Geliştirme modundaki web server'ın aksine konsol her seferinde kodunuzu tekrar yüklemez. Bu yüzden konsol açıkken modelde değişiklik yaparsanız +reload+ komutu girerek tazeleme sağlamalısınız.

h4. Tüm Gönderilerin Listelenmesi

Çalışmanın incelenmesinde en kolay yol gönderilerin listelendiği sayfayı incelemek. +app/controllers/posts_controller.rb+ dosyasını açın ve +index+ eylemine bakın:

<pre>
def index
  @posts = Post.all

  respond_to do |format|
    format.html # index.html.erb
    format.xml  { render :xml => @posts }
  end
end
</pre>

+Post.all+ deyimi +Post+ modelinden veritabanındaki tüm gönderileri getirir. Bunun sonucunda +@posts+ değişkeninde bir array olarak gönderileri saklıyoruz.

İPUCU: Active Record hakkında daha fazla bilgi için "Active Record Query Interface":active_record_querying.html başlığına bakınız.

+respond_to+ bloğu hem HTML hem XML olarak gelen çağrıları cevaplar. Eğer tarayıcıda "http://localhost:3000/posts.xml":http://localhost:3000/posts.xml adresine giderseniz tüm göderileri XML formatında görürsünüz. HTML formatı +app/views/posts/+ içindeki view dosyalarından ilgili eylemin dosyasına göre bir görüntü döner. Rails ilgili eylem içindeki tüm instance değişkenleri görsel için de kullanılabilir hale getirir. +app/views/posts/index.html.erb+ dosyasını inceleyelim:

<pre>
<h1>Listing posts</h1>

<table>
  <tr>
    <th>Name</th>
    <th>Title</th>
    <th>Content</th>
    <th></th>
    <th></th>
    <th></th>
  </tr>

<% @posts.each do |post| %>
  <tr>
    <td><%= post.name %></td>
    <td><%= post.title %></td>
    <td><%= post.content %></td>
    <td><%= link_to 'Show', post %></td>
    <td><%= link_to 'Edit', edit_post_path(post) %></td>
    <td><%= link_to 'Destroy', post, :confirm => 'Are you sure?', :method => :delete %></td>
  </tr>
<% end %>
</table>

<br />

<%= link_to 'New post', new_post_path %>
</pre>

Bu görsel dosyası, +@posts+ array değişkeni üzerinden gönderileri listeliyor ve ilgili linkleri elde ediyor. Görsel içinde birkaç noktaya dikkat edersek:

* +link_to+ bir hyperlink bağlantısı oluşturur
* +edit_post_path+ ve +new_post_path+ Rails'in RESTful yönlendirmelerinde kullandığı yardımcı tekniklerinden gelir. Kontrolörler içinde bu yardımcılardan birçok daha göreceksiniz.

NOT. Rails'in önceki versiyonunda, +&lt;%=h post.name %&gt;+ kullanarak veri içine konan HTML kodlarının sayfada işlem yapması ve sayfanın saldırıya uğraması engellenirdi. Rails 3.0'da bu işlem default olarak yapılır. HTML kodların çalışmasını istiyorsanız +&lt;%= raw post.name %&gt;+ şeklinde yazmalısınız.

İPUCU: Render işlemi için ayrıntılı bilgiyi "Layouts and Rendering in Rails":layouts_and_rendering.html. adresinde bulabilirsiniz.

h4. Yerleşimin Düzenlenmesi

Görsel dosyalarında sadece tarayıcıda HTML'in nasıl görüneceği bilgisi vardır. Rails'de bundan başka +yerleşimler+ (layout) de bulunur. Bunlar görsellerin içine konacağı dosyalardır. Rails tarayıcıya bir görseli dönerken, görselin HTML kodunu yerleşimin HTML kodu içersine yerleştirir ve bu birleşimi döndürür. Rails'in önceki versiyonunda +rails generate scaffold+ komutu çalışınca otomatik olarak kontrolöre ait bir yerleşim dosyası (app/views/layouts/posts.html.erb gibi) üretilirdi. Rails 3.0'da bu değişti. Uygulama çapında bir +yerleşim+ tüm kontrolörler için kullanılır, +app/views/layouts/application.html.erb+. Bu yerleşim dosyasını editörde açın ve +body+ tag'ini değiştirin:

<pre>
<!DOCTYPE html>
<html>
<head>
  <title>Blog</title>
  <%= stylesheet_link_tag :all %>
  <%= javascript_include_tag :defaults %>
  <%= csrf_meta_tags %>
</head>
<body style="background: #EEEEEE;">

<%= yield %>

</body>
</html>
</pre>

Şimdi +/posts+ sayfasını tazelediğinizde sayfa arkaplanın gri renk olduğunu göreceksiniz. Aynı arkaplan tüm görsellerde gri olacaktır.

h4. Yeni Gönderiler Oluşturmak

Yeni gönderi oluşturmak iki eylemden oluşur. İlkönce +new+ eylemi boş bir +Post+ objesi başlatarak yeni gönderi oluşturur:

<pre>
def new
  @post = Post.new

  respond_to do |format|
    format.html # new.html.erb
    format.xml  { render :xml => @post }
  end
end
</pre>

+new.html.erb+ görseli kullanıcıya boş bir gönderi gösterir:

<pre>
  <h1>New post</h1>

  <%= render 'form' %>

  <%= link_to 'Back', posts_path %>
</pre>

+&lt;%= render 'form' %&gt;+ satırı Rails'de _partial_ konusuna ilk girişimizi oluşturacak. Bir partial (kısmi kod), birçok yerde tekrar kullanmak için hazırlanmış Ruby ve HTML kodlardan oluşan kod parçasıdır. Bizim uygulamamızda yeni gönderi oluşturmak için kullanılan form ile olan bir gönderiyi değiştirmek için kullanılan form aynıdır. Her ikisinde de isim ve başlık için birer text field, içerik için bir text area ve gönderiyi kaydetmek için bir buton vardır.

Eğer +views/posts/_form.html.erb+ dosyasına bakarsanız, şunları göreceksiniz:

<pre>
<%= form_for(@post) do |f| %>
  <% if @post.errors.any? %>
  <div id="error_explanation">
    <h2><%= pluralize(@post.errors.count, "error") %> prohibited this post from being saved:</h2>
    <ul>
    <% @post.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
  <% end %>

  <div class="field">
    <%= f.label :name %><br />
    <%= f.text_field :name %>
  </div>
  <div class="field">
    <%= f.label :title %><br />
    <%= f.text_field :title %>
  </div>
  <div class="field">
    <%= f.label :content %><br />
    <%= f.text_area :content %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>
</pre>

Bu kısmi kod tüm instance değişkenleri kendisini çağıran görselden alır ve kullanır, burada yeni gönderi kontrolör tarafından +@post+ değişkenine konur. Hem yeni gönderi hem değiştirme yaparken kontrolör +@post+ değişkenini kullanmaktadır. 

Kısmi kodlar hakkında daha fazla bilgi "Layouts and Rendering in Rails":layouts_and_rendering.html#using-partials klavuzunda bulunabilir.

+form_for+ bloğu bir HTML form üretmek için kullanılır. Bu blok içinde form içerisinde değişik kontroller oluşturmak için metodlar kullanabilirsiniz. Örneğin, +f.text_field :name+ komutu Rails'e form üzerinde bir text input oluşturmasını ve bunu instance değişkenin +name+ sütununu gösterecek şekilde bağlamasını anlatır. Bu metodları sadece formun bağlı olduğu modelin sütunlarına bağlamak için kullanabilirsiniz (yani burada +name+, +title+ ve +content+ ). Rails, +form_for+ yapısını az kodlama yapma amacıyla ve bir modelle direk bağlantı yaptığı için HTML koda tercih eder.

+form_for+ bloğu ayrıca yeni gönderi veya gönderi değiştirme eylemlerinin hangisinin istendiğini çözecek ve formun +action+ tag'i ve gönderi butonu etiketini isteğe göre tayin edecek kadar akıllıdır.

İPUCU: Eğer bir modele bağlı olmayan keyfi alanları olan bir HTML form oluşturmak isterseniz +form_tag+ metodunu kullanın. Bu bir modele bağlı olmayan formlar oluşturmak için gereken metodları kullanır.

Kullanıcı bu form üzerindeki +Create Post+ düğmesini tıkladığında tarayıcı bilgiyi kontrolörün +create+ eylemine gönderir (Rails +create+ metodunu çağıracağını bilir çünkü form bir HTTP POST isteği ile gönderilmiştir, bu daha önce anlattığımız geleneklerdendir):

<pre>
def create
  @post = Post.new(params[:post])

  respond_to do |format|
    if @post.save
      format.html { redirect_to(@post,
                    :notice => 'Post was successfully created.') }
      format.xml  { render :xml => @post,
                    :status => :created, :location => @post }
    else
      format.html { render :action => "new" }
      format.xml  { render :xml => @post.errors,
                    :status => :unprocessable_entity }
    end
  end
end
</pre>

+create+ eylemi formun gönderdiği verilerle yeni bir Post nesnesi üretir, veriyi +params+ hash yapısından alır. Yeni gönderiyi sağlıklı bir şekilde kaydederse +create+ eylemi kullanıcının girişi yaptığı formatta (burada HTML) kaydı gösteren sayfaya döner. Kullanıcıyı üretilen gönderinin +show+ eylemine yönlendirir ve bir bildiriyle kullanıcıya işlemin başarısını bildirir.

Eğer gönderi sağlıklı kaydedilemediyse, mesela denetleme hatası olduysa, kullanıcı tekrar +new+ eylemine yönlendirilip düzeltilip tekrar girilmesini belirten bir hata mesajı verilir.

"Post was successfully created." mesajı Rails'in +flash+ hash yapısında saklanır ve böylece mesaj kullanıcıyı yönlendirecek yardımcı bir mesajla diğer bir eyleme taşınabilir. +create+ eylemi kaydı saklarken başka bir görsele gitmeyip saklamanın ardından +show+ eylemine yönlendiği için bu sayfanın üzerinde "Post was successfully created." mesajı çıkar.

h4. Bir Gönderinin Ayrıntısının Gösterilmesi

Index sayfasında bir gönderinin +show+ linkine tıkladığınızda, sizi +http://localhost:3000/posts/2+ gibi bir sayfaya yönlendirir. Rails bunu +show+ eylemine bir çağrı olarak işler ve +2+ sayısını +:id+ parametresi olarak algılar. İşte +show+ eylemi:

<pre>
def show
  @post = Post.find(params[:id])

  respond_to do |format|
    format.html # show.html.erb
    format.xml  { render :xml => @post }
  end
end
</pre>

+show+ eylemi +id+ değerine göre veritabanından bir gönderiyi bulmak için +Post.find+ metodunu kullanır. Kaydı bulduktan sonra Rails +show.html.erb+ ile bu veriyi gösterir:

<pre>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>


<%= link_to 'Edit', edit_post_path(@post) %> |
<%= link_to 'Back', posts_path %>
</pre>

h4. Editing Posts

Like creating a new post, editing a post is a two-part process. The first step is a request to +edit_post_path(@post)+ with a particular post. This calls the +edit+ action in the controller:

<ruby>
def edit
  @post = Post.find(params[:id])
end
</ruby>

After finding the requested post, Rails uses the +edit.html.erb+ view to display it:

<erb>
<h1>Editing post</h1>

<%= render 'form' %>

<%= link_to 'Show', @post %> |
<%= link_to 'Back', posts_path %>
</erb>

Again, as with the +new+ action, the +edit+ action is using the +form+ partial, this time however, the form will do a PUT action to the PostsController and the submit button will display "Update Post"

Submitting the form created by this view will invoke the +update+ action within the controller:

<ruby>
def update
  @post = Post.find(params[:id])

  respond_to do |format|
    if @post.update_attributes(params[:post])
      format.html { redirect_to(@post,
                    :notice => 'Post was successfully updated.') }
      format.xml  { head :ok }
    else
      format.html { render :action => "edit" }
      format.xml  { render :xml => @post.errors,
                    :status => :unprocessable_entity }
    end
  end
end
</ruby>

In the +update+ action, Rails first uses the +:id+ parameter passed back from the edit view to locate the database record that's being edited. The +update_attributes+ call then takes the rest of the parameters from the request and applies them to this record. If all goes well, the user is redirected to the post's +show+ view. If there are any problems, it's back to the +edit+ view to correct them.

h4. Destroying a Post

Finally, clicking one of the +destroy+ links sends the associated id to the +destroy+ action:

<ruby>
def destroy
  @post = Post.find(params[:id])
  @post.destroy

  respond_to do |format|
    format.html { redirect_to(posts_url) }
    format.xml  { head :ok }
  end
end
</ruby>

The +destroy+ method of an Active Record model instance removes the corresponding record from the database. After that's done, there isn't any record to display, so Rails redirects the user's browser to the index view for the model.

h3. Adding a Second Model

Now that you've seen how a model built with scaffolding looks like, it's time to add a second model to the application. The second model will handle comments on blog posts.

h4. Generating a Model

Models in Rails use a singular name, and their corresponding database tables use a plural name. For the model to hold comments, the convention is to use the name Comment. Even if you don't want to use the entire apparatus set up by scaffolding, most Rails developers still use generators to make things like models and controllers. To create the new model, run this command in your terminal:

<shell>
$ rails generate model Comment commenter:string body:text post:references
</shell>

This command will generate four files:

* +app/models/comment.rb+ - The model
* +db/migrate/20100207235629_create_comments.rb+ - The migration
* +test/unit/comment_test.rb+ and +test/fixtures/comments.yml+ - The test harness.

First, take a look at +comment.rb+:

<ruby>
class Comment < ActiveRecord::Base
  belongs_to :post
end
</ruby>

This is very similar to the +post.rb+ model that you saw earlier. The difference is the line +belongs_to :post+, which sets up an Active Record _association_. You'll learn a little about associations in the next section of this guide.

In addition to the model, Rails has also made a migration to create the corresponding database table:

<ruby>
class CreateComments < ActiveRecord::Migration
  def self.up
    create_table :comments do |t|
      t.string :commenter
      t.text :body
      t.references :post

      t.timestamps
    end
  end

  def self.down
    drop_table :comments
  end
end
</ruby>

The +t.references+ line sets up a foreign key column for the association between the two models. Go ahead and run the migration:

<shell>
$ rake db:migrate
</shell>

Rails is smart enough to only execute the migrations that have not already been run against the current database, so in this case you will just see:

<shell>
==  CreateComments: migrating =================================================
-- create_table(:comments)
   -> 0.0017s
==  CreateComments: migrated (0.0018s) ========================================
</shell>

h4. Associating Models

Active Record associations let you easily declare the relationship between two models. In the case of comments and posts, you could write out the relationships this way:

* Each comment belongs to one post
* One post can have many comments

In fact, this is very close to the syntax that Rails uses to declare this association. You've already seen the line of code inside the Comment model that makes each comment belong to a Post:

<ruby>
class Comment < ActiveRecord::Base
  belongs_to :post
end
</ruby>

You'll need to edit the +post.rb+ file to add the other side of the association:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }

  has_many :comments
end
</ruby>

These two declarations enable a good bit of automatic behavior. For example, if you have an instance variable +@post+ containing a post, you can retrieve all the comments belonging to that post as the array +@post.comments+.

TIP: For more information on Active Record associations, see the "Active Record Associations":association_basics.html guide.

h4. Adding a Route for Comments

As with the +home+ controller, we will need to add a route so that Rails knows where we would like to navigate to see +comments+.  Open up the +config/routes.rb+ file again, you will see an entry that was added automatically for +posts+ near the top by the scaffold generator, +resources :posts+, edit it as follows:

<ruby>
resources :posts do
  resources :comments
end
</ruby>

This creates +comments+ as a _nested resource_ within +posts+. This is another part of capturing the hierarchical relationship that exists between posts and comments.

TIP: For more information on routing, see the "Rails Routing from the Outside In":routing.html guide.

h4. Generating a Controller

With the model in hand, you can turn your attention to creating a matching controller. Again, there's a generator for this:

<shell>
$ rails generate controller Comments
</shell>

This creates four files and one empty directory:

* +app/controllers/comments_controller.rb+ - The controller
* +app/helpers/comments_helper.rb+ - A view helper file
* +test/functional/comments_controller_test.rb+ - The functional tests for the controller
* +test/unit/helpers/comments_helper_test.rb+ - The unit tests for the helper
* +app/views/comments/+ - Views of the controller are stored here

Like with any blog, our readers will create their comments directly after reading the post, and once they have added their comment, will be sent back to the post show page to see their comment now listed.  Due to this, our +CommentsController+ is there to provide a method to create comments and delete SPAM comments when they arrive.

So first, we'll wire up the Post show template (+/app/views/posts/show.html.erb+) to let us make a new comment:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<h2>Add a comment:</h2>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>

<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

This adds a form on the Post show page that creates a new comment, which will call the +CommentsController+ +create+ action, so let's wire that up:

<ruby>
class CommentsController < ApplicationController
  def create
    @post = Post.find(params[:post_id])
    @comment = @post.comments.create(params[:comment])
    redirect_to post_path(@post)
  end
end
</ruby>

You'll see a bit more complexity here than you did in the controller for posts. That's a side-effect of the nesting that you've set up; each request for a comment has to keep track of the post to which the comment is attached, thus the initial find action to the Post model to get the post in question.

In addition, the code takes advantage of some of the methods available for an association. We use the +create+ method on +@post.comments+ to create and save the comment. This will automatically link the comment so that it belongs to that particular post.

Once we have made the new comment, we send the user back to the original post using the +post_path(@post)+ helper. As we have already seen, this calls the +show+ action of the +PostsController+ which in turn renders the +show.html.erb+ template. This is where we want the comment to show, so let's add that to the +app/views/posts/show.html.erb+.

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<h2>Comments</h2>
<% @post.comments.each do |comment| %>
  <p>
    <b>Commenter:</b>
    <%= comment.commenter %>
  </p>

  <p>
    <b>Comment:</b>
    <%= comment.body %>
  </p>
<% end %>

<h2>Add a comment:</h2>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>

<br />

<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

Now you can add posts and comments to your blog and have them show up in the right places.

h3. Refactoring

Now that we have Posts and Comments working, if we take a look at the +app/views/posts/show.html.erb+ template, it's getting long and awkward. We can use partials to clean this up.

h4. Rendering Partial Collections

First we will make a comment partial to extract showing all the comments for the post. Create the file +app/views/comments/_comment.html.erb+ and put the following into it:

<erb>
<p>
  <b>Commenter:</b>
  <%= comment.commenter %>
</p>

<p>
  <b>Comment:</b>
  <%= comment.body %>
</p>
</erb>

Then in the +app/views/posts/show.html.erb+ you can change it to look like the following:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<h2>Comments</h2>
<%= render @post.comments %>

<h2>Add a comment:</h2>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>

<br />

<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

This will now render the partial in +app/views/comments/_comment.html.erb+ once for each comment that is in the +@post.comments+ collection.  As the +render+ method iterates over the <tt>@post.comments</tt> collection, it assigns each comment to a local variable named the same as the partial, in this case +comment+ which is then available in the partial for us to show.

h4. Rendering a Partial Form

Lets also move that new comment section out to it's own partial, again, you create a file +app/views/comments/_form.html.erb+ and in it you put:

<erb>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>
</erb>

Then you make the +app/views/posts/show.html.erb+ look like the following:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<h2>Comments</h2>
<%= render @post.comments %>

<h2>Add a comment:</h2>
<%= render "comments/form" %>

<br />

<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

The second render just defines the partial template we want to render, <tt>comments/form</tt>, Rails is smart enough to spot the forward slash in that string and realize that you want to render the <tt>_form.html.erb</tt> file in the <tt>app/views/comments</tt> directory.

The +@post+ object is available to any partials rendered in the view because we defined it as an instance variable.

h3. Deleting Comments

Another important feature on a blog is being able to delete SPAM comments.  To do this, we need to implement a link of some sort in the view and a +DELETE+ action in the +CommentsController+.

So first, let's add the delete link in the +app/views/comments/_comment.html.erb+ partial:

<erb>
<p>
  <b>Commenter:</b>
  <%= comment.commenter %>
</p>

<p>
  <b>Comment:</b>
  <%= comment.body %>
</p>

<p>
  <%= link_to 'Destroy Comment', [comment.post, comment],
               :confirm => 'Are you sure?',
               :method => :delete %>
</p>
</erb>

Clicking this new "Destroy Comment" link will fire off a <tt>DELETE /posts/:id/comments/:id</tt> to our +CommentsController+, which can then use this to find the comment we want to delete, so let's add a destroy action to our controller:

<ruby>
class CommentsController < ApplicationController

  def create
    @post = Post.find(params[:post_id])
    @comment = @post.comments.create(params[:comment])
    redirect_to post_path(@post)
  end

  def destroy
    @post = Post.find(params[:post_id])
    @comment = @post.comments.find(params[:id])
    @comment.destroy
    redirect_to post_path(@post)
  end

end
</ruby>

The +destroy+ action will find the post we are looking at, locate the comment within the <tt>@post.comments</tt> collection, and then remove it from the database and send us back to the show action for the post.


h4. Deleting Associated Objects

If you delete a post then its associated comments will also need to be deleted. Otherwise they would simply occupy space in the database. Rails allows you to use the +dependent+ option of an association to achieve this. Modify the Post model, +app/models/post.rb+, as follows:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }
  has_many :comments, :dependent => :destroy
end
</ruby>

h3. Security

If you were to publish your blog online, anybody would be able to add, edit and delete posts or delete comments.

Rails provides a very simple HTTP authentication system that will work nicely in this situation. First, we enable simple HTTP based authentication in our <tt>app/controllers/application_controller.rb</tt>:

<ruby>
class ApplicationController < ActionController::Base
  protect_from_forgery

  private

  def authenticate
    authenticate_or_request_with_http_basic do |user_name, password|
      user_name == 'admin' && password == 'password'
    end
  end

end
</ruby>

You can obviously change the username and password to whatever you want.  We put this method inside of +ApplicationController+ so that it is available to all of our controllers.

Then in the +PostsController+ we need to have a way to block access to the various actions if the person is not authenticated, here we can use the Rails <tt>before_filter</tt> method, which allows us to specify that Rails must run a method and only then allow access to the requested action if that method allows it.

To use the before filter, we specify it at the top of our +PostsController+, in this case, we want the user to be authenticated on every action, except for +index+ and +show+, so we write that:

<ruby>
class PostsController < ApplicationController

  before_filter :authenticate, :except => [:index, :show]

  # GET /posts
  # GET /posts.xml
  def index
    @posts = Post.all
    respond_to do |format|
# snipped for brevity
</ruby>

We also only want to allow authenticated users to delete comments, so in the +CommentsController+ we write:

<ruby>
class CommentsController < ApplicationController

  before_filter :authenticate, :only => :destroy

  def create
    @post = Post.find(params[:post_id])
# snipped for brevity
</ruby>

Now if you try to create a new post, you will be greeted with a basic HTTP Authentication challenge

!images/challenge.png(Basic HTTP Authentication Challenge)!


h3. Building a Multi-Model Form

Another feature of your average blog is the ability to tag posts. To implement this feature your application needs to interact with more than one model on a single form. Rails offers support for nested forms.

To demonstrate this, we will add support for giving each post multiple tags, right in the form where you create the post. First, create a new model to hold the tags:

<shell>
$ rails generate model tag name:string post:references
</shell>

Again, run the migration to create the database table:

<shell>
$ rake db:migrate
</shell>

Next, edit the +post.rb+ file to create the other side of the association, and to tell Rails (via the +accepts_nested_attributes_for+ macro) that you intend to edit tags via posts:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }

  has_many :comments, :dependent => :destroy
  has_many :tags

  accepts_nested_attributes_for :tags, :allow_destroy => :true,
    :reject_if => proc { |attrs| attrs.all? { |k, v| v.blank? } }
end
</ruby>

The +:allow_destroy+ option on the nested attribute declaration tells Rails to display a "remove" checkbox on the view that you'll build shortly. The +:reject_if+ option prevents saving new tags that do not have any attributes filled in.

We will modify +views/posts/_form.html.erb+ to render a partial to make a tag:

<erb>
<% @post.tags.build %>
<%= form_for(@post) do |post_form| %>
  <% if @post.errors.any? %>
  <div id="errorExplanation">
    <h2><%= pluralize(@post.errors.count, "error") %> prohibited this post from being saved:</h2>
    <ul>
    <% @post.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
  <% end %>

  <div class="field">
    <%= post_form.label :name %><br />
    <%= post_form.text_field :name %>
  </div>
  <div class="field">
    <%= post_form.label :title %><br />
    <%= post_form.text_field :title %>
  </div>
  <div class="field">
    <%= post_form.label :content %><br />
    <%= post_form.text_area :content %>
  </div>
  <h2>Tags</h2>
  <%= render :partial => 'tags/form',
             :locals => {:form => post_form} %>
  <div class="actions">
    <%= post_form.submit %>
  </div>
<% end %>
</erb>

Note that we have changed the +f+ in +form_for(@post) do |f|+ to +post_form+ to make it easier to understand what is going on.

This example shows another option of the render helper, being able to pass in local variables, in this case, we want the local variable +form+ in the partial to refer to the +post_form+ object.

We also add a <tt>@post.tags.build</tt> at the top of this form, this is to make sure there is a new tag ready to have it's name filled in by the user.  If you do not build the new tag, then the form will not appear as there is no new Tag object ready to create.

Now create the folder <tt>app/views/tags</tt> and make a file in there called <tt>_form.html.erb</tt> which contains the form for the tag:

<erb>
<%= form.fields_for :tags do |tag_form| %>
  <div class="field">
    <%= tag_form.label :name, 'Tag:' %>
    <%= tag_form.text_field :name %>
  </div>
  <% unless tag_form.object.nil? || tag_form.object.new_record? %>
    <div class="field">
      <%= tag_form.label :_destroy, 'Remove:' %>
      <%= tag_form.check_box :_destroy %>
    </div>
  <% end %>
<% end %>
</erb>

Finally, we will edit the <tt>app/views/posts/show.html.erb</tt> template to show our tags.

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<p>
  <b>Tags:</b>
  <%= @post.tags.map { |t| t.name }.join(", ") %>
</p>

<h2>Comments</h2>
<%= render @post.comments %>

<h2>Add a comment:</h2>
<%= render "comments/form" %>


<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

With these changes in place, you'll find that you can edit a post and its tags directly on the same view.

However, that method call <tt>@post.tags.map { |t| t.name }.join(", ")</tt> is awkward, we could handle this by making a helper method.

h3. View Helpers

View Helpers live in <tt>app/helpers</tt> and provide small snippets of reusable code for views.  In our case, we want a method that strings a bunch of objects together using their name attribute and joining them with a comma.  As this is for the Post show template, we put it in the PostsHelper.

Open up <tt>app/helpers/posts_helper.rb</tt> and add the following:

<erb>
module PostsHelper
  def join_tags(post)
    post.tags.map { |t| t.name }.join(", ")
  end
end
</erb>

Now you can edit the view in <tt>app/views/posts/show.html.erb</tt> to look like this:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<p>
  <b>Tags:</b>
  <%= join_tags(@post) %>
</p>

<h2>Comments</h2>
<%= render @post.comments %>

<h2>Add a comment:</h2>
<%= render "comments/form" %>


<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

h3. What's Next?

Now that you've seen your first Rails application, you should feel free to update it and experiment on your own. But you don't have to do everything without help. As you need assistance getting up and running with Rails, feel free to consult these support resources:

* The "Ruby on Rails guides":index.html
* The "Ruby on Rails Tutorial":http://railstutorial.org/book
* The "Ruby on Rails mailing list":http://groups.google.com/group/rubyonrails-talk
* The "#rubyonrails":irc://irc.freenode.net/#rubyonrails channel on irc.freenode.net
* The "Rails Wiki":http://wiki.rubyonrails.org/

Rails also comes with built-in help that you can generate using the rake command-line utility:

* Running +rake doc:guides+ will put a full copy of the Rails Guides in the +doc/guides+ folder of your application. Open +doc/guides/index.html+ in your web browser to explore the Guides.
* Running +rake doc:rails+ will put a full copy of the API documentation for Rails in the +doc/api+ folder of your application. Open +doc/api/index.html+ in your web browser to explore the API documentation.

h3. Configuration Gotchas

The easiest way to work with Rails is to store all external data as UTF-8. If you don't, Ruby libraries and Rails will often be able to convert your native data into UTF-8, but this doesn't always work reliably, so you're better off ensuring that all external data is UTF-8.

If you have made a mistake in this area, the most common symptom is a black diamond with a question mark inside appearing in the browser. Another common symptom is characters like "Ã¼" appearing instead of "ü". Rails takes a number of internal steps to mitigate common causes of these problems that can be automatically detected and corrected. However, if you have external data that is not stored as UTF-8, it can occasionally result in these kinds of issues that cannot be automatically detected by Rails and corrected.

Two very common sources of data that are not UTF-8:
* Your text editor: Most text editors (such as Textmate), default to saving files as
  UTF-8. If your text editor does not, this can result in special characters that you
  enter in your templates (such as é) to appear as a diamond with a question mark inside
  in the browser. This also applies to your I18N translation files.
  Most editors that do not already default to UTF-8 (such as some versions of
  Dreamweaver) offer a way to change the default to UTF-8. Do so.
* Your database. Rails defaults to converting data from your database into UTF-8 at
  the boundary. However, if your database is not using UTF-8 internally, it may not
  be able to store all characters that your users enter. For instance, if your database
  is using Latin-1 internally, and your user enters a Russian, Hebrew, or Japanese
  character, the data will be lost forever once it enters the database. If possible,
  use UTF-8 as the internal storage of your database.

h3. Changelog

* August 30, 2010: Minor editing after Rails 3 release by "Joost Baaij":http://www.spacebabies.nl
* July 12, 2010: Fixes, editing and updating of code samples by "Jaime Iniesta":http://jaimeiniesta.com
* May 16, 2010: Added a section on configuration gotchas to address common encoding problems that people might have by "Yehuda Katz":http://www.yehudakatz.com
* April 30, 2010: Fixes, editing and updating of code samples by "Rohit Arondekar":http://rohitarondekar.com
* April 25, 2010: Couple of more minor fixups "Mikel Lindsaar":credits.html#raasdnil
* April 1, 2010: Fixed document to validate XHTML 1.0 Strict. "Jaime Iniesta":http://jaimeiniesta.com
* February 8, 2010: Full re-write for Rails 3.0-beta, added helpers and before_filters, refactored code by "Mikel Lindsaar":credits.html#raasdnil
* January 24, 2010: Re-write for Rails 3.0 by "Mikel Lindsaar":credits.html#raasdnil
* July 18, 2009: Minor cleanup in anticipation of Rails 2.3.3 by "Mike Gunderloy":credits.html#mgunderloy
* February 1, 2009: Updated for Rails 2.3 by "Mike Gunderloy":credits.html#mgunderloy
* November 3, 2008: Formatting patch from Dave Rothlisberger
* November 1, 2008: First approved version by "Mike Gunderloy":credits.html#mgunderloy
* October 16, 2008: Revised based on feedback from Pratik Naik by "Mike Gunderloy":credits.html#mgunderloy (not yet approved for publication)
* October 13, 2008: First complete draft by "Mike Gunderloy":credits.html#mgunderloy (not yet approved for publication)
* October 12, 2008: More detail, rearrangement, editing by "Mike Gunderloy":credits.html#mgunderloy (not yet approved for publication)
* September 8, 2008: initial version by "James Miller":credits.html#bensie (not yet approved for publication)
