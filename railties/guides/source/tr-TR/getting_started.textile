h2. Rails'e Başlamak

Bu klavuz Ruby on Rails'i kurmanız ve çalıştırmanız için gerekenleri içerir. Onu okuduktan sonra şu konularda bilgi sahibi olacaksınız:

* Rails Kurulumu, yeni bir Rails uygulaması üretimi ve uygulamanızın bir veritabanına bağlantısı
* Bir Rails uygulamasının genel yapısı
* MVC (Model, View Controller) ve RESTful tasarımın temel prensipleri
* Bir Rails uygulamasının başlangıç kısımlarını nasıl çabukça üretirsiniz.

endprologue.

WARNING. Bu klavuz Rails 3.0 a göre düzenlenmiştir. Burada gösterilen bazı kodlar önceki Rails versiyonlarında çalışmaz.

h3. Klavuzun Varsayımları

Bu klavuz Rails'e sıfırdan başlamak isteyen yeni programcılar için düzenlenmiştir. Daha önceden herhangi bir Rails bilginiz olmasını beklemez. Ancak, başlamadan önce şu bileşenlerin kurulu olması gerekir:

* "Ruby":http://www.ruby-lang.org/en/downloads programlama dili versiyon 1.8.7 ya da daha yüksek olmalı

TIP: Ruby 1.8.7 p248 ve p249 Rails 3.0'ın çakılmasına neden olan bug'lar içeriyordu. Ruby Enterprise Edition release 1.8.7-2010.02 den itibaren bu düzeltildi. Ruby 1.9.1 ise Rails 3.0'da segfault hataları veriyor, o yüzden 1.9.x serisiyle Rails 3.0 kullanmak isterseniz Ruby 1.9.2 den itibaren kullanın.

* "RubyGems":http://rubyforge.org/frs/?group_id=126 paketleme sistemi
* Çalışan bir "SQLite3 Veritabanı":http://www.sqlite.org

Rails, Ruby programlama dili üzerinden çalışan bir web uygulama geliştirme iskeletidir. Eğer Ruby hakkında önceden bilginiz yoksa, Rails öğrenirken zorlanacaksınız. Ruby öğrenmek için birçok bedava kaynak vardır, bazıları şunlar:

* "Mr. Neighborly's Humble Little Ruby Book":http://www.humblelittlerubybook.com
* "Programming Ruby":http://www.ruby-doc.org/docs/ProgrammingRuby/
* "Why's (Poignant) Guide to Ruby":http://mislav.uniqpath.com/poignant-guide/

h3. Rails Nedir?

Rails, Ruby programlama dili üzerinden çalışan bir web uygulama geliştirme iskeletidir. Her geliştiricinin başlarken ihtiyaç duyacağı şeyler hakkında varsayımlarda bulunarak web uygulamalarının yapılmasını kolaylaştırmak için tasarlanmıştır. Diğer benzerlerinden çok daha az kod yazarak başarıya ulaşmanızı sağlar. Uzmanlaşmış Rails kullanıcıları web uygulaması geliştirmenin eğlenceli hale getirildiğini de söyler.

Rails dikkafalı bir yazılımdır. Birşeyleri yapmanın en iyi yolu olduğunu ve kendisinin bu yolu kullandığını savunur ve bazen diğer yolları da inkar eder. Eğer "Rails yolu"nu öğrenirseniz, yüksek ihtimalle üretkenliğinizde büyük bir atış olduğunu göreceksiniz. Eğer daha önceki tecrübelerinizden yada bildiğiniz dillerden birşeyleri uygulamaya kalkarsanız daha başarısız olursunuz.

Rails filozofisi birkaç temel üzerine oturmuştur :

* DRY - "Dont Repeat Yourself (kendini tekrar edip durma)" - Aynı kodu tekrar tekrar yazmanın kötü birşey olduğunu savunur.
* Convention Over Configuration - Konfigürasyon kuralları koyar. Rails sizin na yapacağınıza ve nasıl yapacağınıza dair varsayımlarda bulunarak her küçük ayrıntıyı sayısız defa ayarlamanızı engeller.
* REST kaynaklarınızı ve standart HTTP işlerini en hızlı ilerlenecek şekilde ayarlayan bir web uygulama düzenidir.

h4. MVC Mimarisi

Rails'in merkezi Model, View, Controller mimarisidir, genellikle MVC diye çağrılır. MVC'nin avantajları şunlar :

* Kullanıcı arabirimi ile iş yapan lojiği biribrinden ayırır.
* DRY prensiplerine bağlı kalmayı kolaylaştırır.
* Farklı tiplerde kodlamaların berraklığı sayesinde bakım ve modifikasyon kolaylaşır.

h5. Modeller

Bir model, uygulama ve verileri arasındaki işlemleri sağlar. Rails yapısında modeller esas olarak bağlı veritabanı ile iletişimin kurallarını yönetir. Birçok durumda veri tabanınızdaki her tabloya karşı uygulamanızda bir model olacaktır. Uygulamanızın arkaplandaki lojiği çoğunlukla bu modeller üzerinde işlem yapacaktır.

h5. View'lar (Görseller)

Görseller uygulamanızın kullanıcı arabirimini oluştururlar. Rails'de görseller, genellikle görevleri veriyi sunmak olan ruby kodlarıyla birleştirilmiş HTML dosyalarıdır. Görseller internet tarayıcılarında verileri göstermek veya uygulamanızdan yapılacak istekleri iletmede kullanılır.

h5. Controller'lar 

Kontrolörler, modeller ve görseller arasında birleştirici görevi yaparlar. Rails'de kontrolörler, webten gelen istekleri işlemekle, modelleri veri için sorgulamakla ve verileri kullanıcıya sunulması için görsellere iletmekle sorumludurlar.

h4. Rails'in Bileşenleri

Rails, birçok özgün bileşenle birlikte gelir.

* Action Pack
  ** Action Controller
  ** Action Dispatch
  ** Action View
* Action Mailer
* Active Model
* Active Record
* Active Resource
* Active Support
* Railties


h5. Action Pack (Eylem Paketi)

Action Pack içinde Action Controller, Action View ve Action Dispatch bileşenlerinden oluşan tek bir gem'dir. MVC'nin VC parçasını oluşturur.

h5. Action Controller (kontrolör eylemleri)

Action Controller, bir Rails uygulamasında kontrolörleri yönetir. Action Controller, Rails uygulamasına gelen istekleri işleyerek parametreleri ayırır ve onları ilgili eylemlere dağıtır. Action Controller tarafından sağlanan servisler içinde oturum yönetimi, görsel kalıpların yayınlanması ve yönlendirmeler vardır.

h5. Action View (görsel eylemleri)

Action View, Rails uygulamanızdaki görselleri yönetir. Default olarak HTML ve XML çıktı üretebilir. Action View, görsel kalıpları yönetir. Bunlar içinde içiçe kalıpların işlenmesi ve Ajax desteği de vardır.

h5. Action Dispatch (dağıtım eylemleri)

Action Dispatch, gelen web isteklerinin yönlendirilmesini yönetir ve istediğiniz şekilde sizin uygulamanıza veya diğer bir Rack uygulamasına dağıtımını sağlar. 

h5. Action Mailer

Action Mailer, e-mail servisleri üretmek için bir iskelettir. Action Mailer'ı gelen mailleri işlemekte ve basit bir yazıdan birçok kalıplarda komplex e-maillere kadar mail hazırlayıp göndermede kullanabilirsiniz.

h5. Active Model

Active Model, Action Pack gem servisleri ve Active Record gibi obje ilişkileri yönlendirme gemleri arasında bir bağlaşım sağlar. Active Model ile Active Record yerine eğer uygulmanızın ihtiyacı varsa diğer ORM iskeletleri de kullanabilirsiniz.

h5. Active Record

Active Record bir Rails uygulamasında modeller için temeldir. Veri tabanından bağımsız olmayı, basit CRUD işlevlerini ve modellerin bir diğerleriyle ilişkisini sağlar.

h5. Active Resource

Active Resource, işlevsel nesnelerle REST temelli web servisleri arasında bağlantı sağlayan bir iskelet sağlar. CRUD mantığıyla web temelli kaynaklar ve yerel nesneler arasında bir yol çizer.

h5. Active Support

Active Support, Rails uygulamaları için yazılmış, hem merkezde hem uygulamanızda kullanılan gelişmiş birçok Ruby kütüphane ilaveleri içerir.

h5. Railties

Railties yeni bir Rails uygulaması için kod üretmekte ve değişik iskeletlerle plugin'leri Rails uygulamasında içermek için kullanılan merkez ünitedir.

h4. REST

Rest, Representational State Transfer cümlesini ifade eder ve RESTfull mimarisinin temelidir. Bu Roy Fielding'in ağ temelli yazılım mimarileri ve stillerini belirten doktora tezinden esinlenmiştir. Bu teze göre Rails uygulamasına şu ana özellikler kazandırılmıştır :

* Kaynakları gösteren URL ler benzeri kaynak imleri kullanmak.
* Sistem bileşenleri arasında kaynakların durumunu taşımak.

Örneğin Bir Rails uygulamasına şöyle bir istek gelsin :

<tt>DELETE /photos/17</tt>

 yazımından anlaşılacağı gibi id'si 17 olan bir fotoğrafın silinmesi isteğidir. REST web uygulamaları için doğal bir yöntemdir ve Rails bunu yöneterek sizi birçok karmaşık işten ve tarayıcı süprizlerinden kurtarır.

Eğer REST yapısı hakkında ve Fielding'in tezi hakkında daha fazla bilgi sahibi olmak isterseniz bu kaynaklara bakabilirsiniz :

* "A Brief Introduction to REST":http://www.infoq.com/articles/rest-introduction by Stefan Tilkov
* "An Introduction to REST":http://bitworking.org/news/373/An-Introduction-to-REST (video tutorial) by Joe Gregorio
* "Representational State Transfer":http://en.wikipedia.org/wiki/Representational_State_Transfer article in Wikipedia
* "How to GET a Cup of Coffee":http://www.infoq.com/articles/webber-rest-workflow by Jim Webber, Savas Parastatidis & Ian Robinson

h3. Yeni Bir Rails Projesi Üretmek

Eğer bu klavuzu takip ederseniz, <tt>blog</tt> adında bir Rails uygulaması üreteceksiniz, çok basit bir web günlüğü. Uygulamayı inşa etmeye başlamadan önce, Rails'in sisteminizde kurulu olduğundan emin olmalısınız.

h4. Rails Kurulumu

Birçok durumda, Rails kurmanın en kolay yolu RubyGems avantajını kullanmak olacaktır:

<shell>
Genellikle bu komutu root kullanıcı olarak çalıştırmanız gerekir: 
# gem install rails
</shell>

TIP. Eğer Windows kullanıyorsanız, Instant Rails'in kurulumunu daha basit bulacaksınız. Gerçi Instant Rails en son versiyondan genelde geride kalıyor ama. Ayrıca windos üzerinde Rails geliştirme yapmak diğer sistemlere nazaran daha keyifsizdir. Eğer mümkünse tavsiyemiz windows yerine bir Linux sanal makina yardımıyla Rails çalışmanızdır.

h4. Blog Uygulmasını Üretmek

Bu klavuzu kullanmanın en iyi yolu sırası geldiğinde her adımı takip etmek, bu örneği yapmak için gereken hiçbir kodlama dışarda bırakılmamıştır. Bu yüzden adım adım izleyebilirsiniz. Eğer bitmiş kodu görmek isterseniz, "Getting Started Code":http://github.com/mikel/getting-started-code dan indirebilirsiniz.

Başlamak için bir konsol (terminal) açın ve uygulamanızı koymak istediğiniz ve dosya yazma hakkınızın bulunduğu bir klasöre gidin ve şunu yazın:

<shell>
$ rails new blog
</shell>

Bu "blog" adlı klasör içinde Blog ismi verilen bir uygulama üretecektir.

TIP: Rails Uygulama Üretecinin tüm komut satır parametrelerini <tt>rails -h</tt> komutuyla görebilirsiniz.

Uygulamanın üretilmesini hata mesajı almadan birçok dosya oluşturulmasından gördükten sonra uygulamanın bulunduğu klasöre geçin:

<shell>
$ cd blog
</shell>

Rails blog adında bir klasör oluşturdu. Bu klasörü açın ve inceleyin. Bu tutorial'de çoğunlukla "app" klasöründe çalışılacak fakat Rails'in ürettiği klasörlerde basit bir gezinti yapalım:

|_.Dosya/Klasör|_.Amacı|
|Gemfile| Bu dosya Rails uygulamanızın hangi Gem'lere bağlantılı olduğunu belirtir.|
|README|README dosyası uygulamanız hakkında kısa bilgi bulundurmalıdır. Onda uygulamanızın ne iş yaptığını, nasıl ayarlandığını vb. bilgileri bulundurmalısınız.|
|Rakefile|Bu dosyada terminalden çalıştırılabilen batch işler bulunur.|
|app/|Bu klasörde uygulamanızın kontrolör ve görselleri bulunur. Bu klavuzun geri kalan kısmında bu klasöre yoğunlaşacaksınız.|
|config/|uygulamanızın çalışma kuralları. yönlendirmeleri, ve veritabanı ayarlamaları vs. bu klasördedir.|
|config.ru|Rack temelli serverlar için uygulamayı başlatma konfigürasyonları.|
|db/|Veritabanınızın yapısını barındırır. Ayrıca veritabanı birleştirmelerini (Migration) içerir. Birleştirmeleri ilerde göreceksiniz.|
|doc/|Uygulamanızın dokümanları bu klasördedir.|
|lib/|Uygulamanızın genişlemesi için modüller buradadır. (bu klavuzda anlatılmamıştır).|
|log/|Uygulamanın log dosyaları.|
|public/|Dış dünyadan olduğu şekliyle ulaşılabilen yegane dosyalar buradadır. Burada tüm resimleriniz, javascriptleriniz, stilleriniz ve diğer sunacağınız dosyalar bulunur.|
|script/|Uygulamanızı çalıştırmak ve yükleme ve diğer çalışma işlevlerinin script'leri içeren klasör.|
|test/|Test işlemleri , bağlayıcılar ve diğer test yardımcıları buradadır. Bu konular "Rails uygulamasının test edilmesi":testing.html bölümünde işlenecek.|
|tmp/|Geçici dosyalar|
|vendor/|Tüm 3. parti yazılımları buradadır. Tipik bir Rails uygulamasında, Gem dosyaları, pluginler ve projenizin içine gömecekseniz Rails kaynak kodu bulunur.|

h4. Gerekli Gemlerin Kurulması

Rails uygulamanızın kullandığı tüm gemleri vendor klasöründe işlemek için "Bundler":http://gembundler.com/v1.0/index.html gemi kullanır. Default olan dışında özel bir gem kullanmayacağımız için sadece şunu yapmamız gerekiyor:

<shell>
# bundle install
</shell>

h4. Bir Veritabanı Tanıtmak

Hemen tüm Rails uygulamaları bir veritabanı kullanır. Kullanılacak veritabanı +config/database.yml+ dosyasında tarif edilir. 
Eğer yeni bir Rails uygulamasında bu dosyayı açarsanız SQLITE3 bir veritabanı tarif edildiğini görürsünüz. Bu dosyada Railsin kullandığı 3 değişik ortama ait kısımlar vardır:

* +Development+ (geliştirme) ortamı uygulamanızı geliştirirken manual iletişim kurabileceğiniz ortamdır.
* +Test+ ortamı uygulamanın otomatize testlerini çalıştırabileceğiniz ortamdır.
* +Production+ (üretim) ortamı uygulamanızı dünyanın kullanımı için yayınlamanızda kullanılır.

h5. Bir SQLite3 veritabanı düzenlemek

Rails, hafif server'sız bir veritabanı olan SQLite3 desteği ile gelir. Çok çalışan uygulamalar SQLite3 veritabanını zorlasa da geliştirme ortamı için idealdir. Rails yeni bir uygulama başlattığında SQLite3 olarak yapılanır ama istediğiniz zaman değiştirebilirsiniz.

Bunlar geliştirme ortamı bölümü için (<tt>config/database</tt>) dosyasının default yapılandırması :

<yaml>
development:
  adapter: sqlite3
  database: db/development.sqlite3
  pool: 5
  timeout: 5000
</yaml>

NOTE: Bu klavuzda verilerimizi saklamak için bir SQLite3 veritabanı kullanıyoruz, bu yüzden veritabanı konfigürasyon dosyasında bir değişiklik yapmamıza gerek yok. Rails ayrıca MySQL ve PrstgreSQL destekler ve diğer birçok veritabanları için plugin'leri  vardır. Eğer halihazırda kullandığınız bir veritabanı varsa Rails'in yüksek ihtimalle ona uygun bir adaptörü vardır.

h5. MySQL Veritabanı Konfigürasyonu

Eğer birlikte gelen SQLite3 veritabanı yerine MySQL kullanmayı tercih ederseniz, database.yml dosyanız farklı olmalıdır. İşte geliştirme ortamı bölümü:

<yaml>
development:
  adapter: mysql2
  encoding: utf8
  database: blog_development
  pool: 5
  username: root
  password:
  socket: /tmp/mysql.sock
</yaml>

Eğer geliştirme yatığınız bilgisayardaki MySQL server root kullanıcısı boş şifreyle çalışıyorsa bu konfigürasyon çalışacaktır. Aksi halde kullanıcı adı ve şifrenin server kullanıcısına uygun şekilde değiştirilmesi gerekir.

h5. PostgreSQL veritabanı konfigürasyonu

Son olarak, eğer PostgreSQL veritabanı kullanmayı tercih ederseniz "config/database.yml" dosyanız buna göre ayarlanmalıdır:

<yaml>
development:
  adapter: postgresql
  encoding: unicode
  database: blog_development
  pool: 5
  username: blog
  password:
</yaml>

Kullanıcı adı ve şifreyi doğru şekilde değiştirin.

h4. Veritabanı Oluşturulması

Şu anda veritabanı konfigürasyonunuz tamam, şimdi Rails'in sizin için boş bir veritabanı üretmesinin zamanı. Bunu şu komutu girerek yapabilirsiniz:

<shell>
$ rake db:create
</shell>

Bu komut <tt>db/</tt> klasöründe geliştirme ve test veritabanlarınızı oluşturur.

TIP: Rake komutu Rails'in birçok şey için kullandığı genel amaçlı bir kod çalıştırıcıdır. Olası komutları +rake -T+ komutu girerek görebilirsiniz.

h3. Merhaba Rails!

Yeni bir dile başlamanın klasik yolu ekrana yazılı birşeyler getirmektir. Rails'de bunun olması için uygulama server'ı çalıştırmalısınız.

h4. Web Server'ı Çalıştırmak

Aslında şu ana kadar yaptıklarınızla aktif bir Rails uygulamanız hazır. Bunu görmek için geliştirme makinenizde web server'ı başlatmanız gerekiyor:

<shell>
$ rails server
</shell>

Bu default olarak bir Mongrel web server başlatacaktır.(Rails diğer farklı server'lar da kullanabilir, mesela mongrel yoksa otomatikman webrick çalışır). Uygulamanızı çalışır şekilde görmek için bir tarayıcı açın ve "http://localhost:3000":http://localhost:3000 adresini girin. Rails'in default bilgilendirme ekranı gelecektir:

!images/rails_welcome.png(Welcome Aboard screenshot)!

TIP: Web server'ı durdurmak için çalıştırdığınız konsol ekranında Ctrl+C basmanız gerekir. Geliştirme modunda, genellikle Rails server'ı durdurmanız gerekmez; dosyalarda yaptığınız değişiklikler server'a otomatik yüklenecektir.

“Welcome Aboard” yeni bir Rails uygulamasının tüten buharıdır: uygulamanızın server'dan yayınlanması için herşeyn uygun olduğundan emin olmak içindir. Ayrıca _About your application’s environment_ bağlantısına tıklayarak uygulamanızın kullandığı ortam hakkında bilgi edinebilirsiniz.

h4. "Merhaba" de Rails

Railsin "Merhaba" demesi için, en az bir kontrolör ve bir görsel ihtiyacınız vardır. Çok şükür ki bunu tek komutla yapabilirsiniz. Şu komutu terminalden girin:

<shell>
$ rails generate controller home index
</shell>

TIP: Eğer Windows'taysanız yada Ruby kurulumunuz standart olmayan bir kurulumdaysa Ruby'ye rails komutunun yolunu da net olarak belirtmeniz gerekir: +ruby \path\to\rails generate controller home index+.

Rails sizin için bazı dosyalar üretecektir. Biri de +app/views/home/index.html.erb+. Bu +home+ kontrolörünün +index+ eylemi sayfasını göstermekte kullanılacak olan kalıp dosyadır. Bu dosyayı editörde açıp içine sadece şu satırı koyun gerisini silin:

<code class="html">
<h1>Merhaba Rails!</h1>
</code>

h4. Uygulamanın Ana Sayfasının Ayarlanması

Şimdiye kadar kontrolör ve görsel dosyasını hazırladık, Rails'e "Merhaba Rails" mesajını görmek istediğimizi anlatmalıyız. Bu durumda "http://localhost:3000":http://localhost:3000 adresi girince "Welcome Aboard" yerine hazırladığımız görselin çıkmasını istiyoruz.

Bunu yapmanın ilk adımı uygulamanın default sayfasını silmek:

<shell>
$ rm public/index.html
</shell>

Rails yayınlama yaparken +public+ klasöründeki statik dosyaları bizim kontrolörle ürettiğimiz dinamik dosyalara tercih edeceği için bunu yapmamız gerekir.

Şimdi Rails'e gerçek ana sayfanın nerede olduğunu anlamanız gerekiyor. +config/routes.rb+ dosyasını editörde açın. Bu uygulamanızın Rails'e gelen çağrılarını nasıl yönlendireceğini anlatan DSL(Domain Spesific Language) girdileri olan yönlendirme dosyasıdır. Bu dosyada başta sadece yorumlar vardır, bu yorumlarda örnek yönlendirmeler vardır. +root :to+ ile başlayan satırın yorum tikini kaldırın ve şu hale getirin:

<ruby>
Blog::Application.routes.draw do

  #...
  # You can have the root of your site routed with "root"
  # just remember to delete public/index.html.
  root :to => "home#index"
</ruby>

+root :to => "home#index"+ satırı Rails'e root eylemini "home" kontrolörü "index" eylemine yönlendirmesini anlatır. 

Eğer şimdi "http://localhost:3000":http://localhost:3000 adresine gidersek +Merhaba Rails!+ mesajını görebiliriz. 

NOTE. Daha fazla bilgi için "Rails Routing from the Outside In":routing.html adresine bakınız.

h3. Scaffolding ile hızlı hazırlık ve çalıştırma.

Rails _Scaffolding_ uygulamanın ana parçalarının üretilmesi için hızlı bir yoldur. Modeller, görseller ve kontrolörleri bir kerede üretmek isterseniz scaffolding size gereken araçtır.

h3. Bir Kaynak Üretmek

Blog uygulamasına göre gönderilerin kaydedileceği bir "Post" kaynağı üreterek başlamak gerekir: bu bir tane blog gönderisi barındıracaktır. Bunu yapmak için konsoldan şu komutu girin:

<shell>
$ rails generate scaffold Post name:string title:string content:text
</shell>

NOTE. Scaffolding'in kendi doğrultusunda hazırladığı kodu sizin tercihlerinize uymayabilir. Çoğunlukla ürettiği kodları değiştirmek gerekecektir. Uzmanlık kazanmış programcılar genellikle kodlarını baştan kendileri üretir. Ama başlangıç seviyesi için gereklidir.

Scaffold jeneratör uygulamanıza 15 dosya üretir, bazı klasörler üretir ve bazılarını da edit eder. Şimdi bunlara kısaca bakalım:

|_.Dosya                                       |_.Amacı|
|db/migrate/20100207214725_create_posts.rb    |Veritabanınızda posts tablosunu üretmek için birleştirme dosyasıdır. Dosya isminde üretildiği anın tarihi olduğu için sizin dosyanızın ismi değişik olacaktır.|
|app/models/post.rb                           |"Post" modelinin dosyası|
|test/fixtures/posts.yml                      |Test amaçlı hazırlanmış sahte gönderi verileri|
|app/controllers/posts_controller.rb          |Gönderilerin kontrolör dosyası|
|app/views/posts/index.html.erb               |Tüm gönderilerin yer aldığı görsel dosyası |
|app/views/posts/edit.html.erb                |Bir gönderiyi düzenlemek için görsel sayfası|
|app/views/posts/show.html.erb                |Birtek gönderiyi göstermek için görsel dosyası|
|app/views/posts/new.html.erb                 |Yeni bir gönderi hazırlama görseli|
|app/views/posts/_form.html.erb               |Hem edit hem new eyleminde kullanılan form görüntüsü parçası|
|app/helpers/posts_helper.rb                  |Post görsellerinde kullanmak için yardımcı fonksiyonlar|
|test/unit/post_test.rb                       |Gönderilerin modeli (posts) için birim test kalıbı|
|test/functional/posts_controller_test.rb     |Gönderilerin kontrolörü için fonksiyonel test kalıbı|
|test/unit/helpers/posts_helper_test.rb       |Yardımcılar için test kalıbı|
|config/routes.rb                             |Gönderiler için yönlendirmeler amacıyla düzenlendi|
|public/stylesheets/scaffold.css              |Scaffold ile hazırlanan görseller için hazırlanmış CSS dosyası|

h4. Veritabanı Birleştirme Yapılması (Migration)

+rails generate scaffold+ komutunun ürünlerinden biri de _veritabanı birleştirmesi_ dir. Birleştirmeler (Migration) veritabanı tablolarının üretilmesi ve değiştirilmesini basitleştirmek için kullanılan Ruby sınıflarıdır. Rails birleştirmeler için rake komutunu kullanır, ve bir birleştirme uygulandıktan sonra geri alınabilir. Birleştirme dosyaları, hangi sırada yapıldıklarından emin olmak için yapıldıkları zamanın kodunu içerirler.

Eğer +db/migrate/20100207214725_create_posts.rb+ dosyasının içine bakarsanız (hatırlayın, sizinkinin ismi farklı olacaktır), şunları bulursunuz:

<ruby>
class CreatePosts < ActiveRecord::Migration
  def self.up
    create_table :posts do |t|
      t.string :name
      t.string :title
      t.text :content

      t.timestamps
    end
  end

  def self.down
    drop_table :posts
  end
end
</ruby>

Yukardaki birleştirme iki metod üretir, +up+ bu birlştirmeyi çalıştırdığınızda aktif olur ve +down+ ilerde birleştirmeleri geri almak isterseniz çalışır. Bu görüntüde +up+ komutu +posts+ tablosunu iki string ve bir text sütunu ile oluşturur. Ayrıca kayıtların üretildiği ve update edildiği tarihler için de timestamp alanları üretir. Rails birleştirmeleri hakkında daha fazla bilgi "Rails Database Migrations":migrations.html klavuzunda bulunabilir.

Şimdi birleştirmenin gerçekleşmesi için rake komutu çalıştırın:

<shell>
$ rake db:migrate
</shell>

Rails birleştirme komutunu işletecek ve size +posts+ tablosunu ürettiğini bildirecektir.

<shell>
==  CreatePosts: migrating ====================================================
-- create_table(:posts)
   -> 0.0019s
==  CreatePosts: migrated (0.0020s) ===========================================
</shell>

NOTE. Şu anda geliştirme ortamında çalıştığınız için bu komut +config/database.yml+ dosyasının +development+ kısmında belirtilen veritabanında işlem yapacaktır.

h4. Bir Bağlantı Eklemek

Önceden ürettiğiniz ana sayfaya gönderilere gitmek için bir bağlantı ekleyebilirsiniz. +app/views/home/index.html.erb+ dosyasını açın ve şöyle değiştirin:

<code lang="ruby">
<h1>Merhaba Rails!</h1>
<%= link_to "Bloğum", posts_path %>
</code>

+link_to+ metodu Rails'in içerdiği görsel yardımcılarından biridir. Yazılacak yazı ve gidilecek yer parametrelerinden bir hyperlink oluşturur - bu durumda gönderilere bağlantı kurulmuş.

h4. Tarayıcıda Gönderileri Çalışmak

Şimdi gönderilerle çalışmaya başlayabilirsiniz. Bunu yapmak için "http://localhost:3000":http://localhost:3000/ adresine gidin ve "Bloğum" linkini tıklayın:

!images/posts_index.png(Posts Index screenshot)!

Bu gönderilerin +index+ görsel sayfası için Rails'in sunusu sonucudur. Henüz veritabanında herhangibir gönderi yoktur, fakat +New Post+ bağlantısına tıklarsanız yeni bir tane üretebilirsiniz. Bundan sonra gönderileri düzenleyebilir, ayrıntılarını inceleyebilir ve silebilirsiniz. Tüm bu HTML ve lojik tek bir satır +rails generate scaffold+ komutuyla üretildi.

TIP: Geliştirme modunda (default olarak bu modda çalışmaktasınız) Rails her tarayıcı isteğinde sayfaları tekrar yükler bu yüzden web server'ın kapatılıp açılmasına gerek yoktur.

Tebrikler, Rails'i kullanmaya başladınız! Şimdi hepsinin nasıl çalıştığını göreceksiniz.

h4. Model

+app/models/post.rb+ model dosyası şu anda çok basit:

<ruby>
class Post < ActiveRecord::Base
end
</ruby>

Bu haliyle söylanacak pek birşey yok - sadece +Post+ sınıfı +ActiveRecord::Base+ sınıfından türetilmiştir. Active Record Rails modellerine bedavaya birçok hizmet sunar. Basit veritabanı CRUD (Create, Read, Update, Destroy) işlemleri, veri denetlemeleri, karmaşık sorgu işlemleri ve birçok modelin diğer biriyle bağlanması gibi.

h4. Bazı Veri Denetimleri Eklenmesi

Rails, modellere gönderdiğiniz veriler üzerinde denetleme yapan metodlar içerir. +app/models/post.rb+ dosyasnı açın ve şöyle düzenleyin:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }
end
</ruby>

Bu değişiklikler, tüm gönderilerin ismi ve etiketi olmasını garanti eder ve etiketin en az 5 karakter uzunluğunda olmasını garanti eder. Rails bir model üzerinde değişik koşulları denetleyebilir. Sütun verilerinin varlığı, benzersizliği, düzeni ve bağlı objelerin varlığı.

h4. Konsolun Kullanımı

Denetlemelerinizin çalışmasını görmek için konsolu kullanabilirsiniz. Konsol uygulamanızın içinde Ruby kodu çalıştırabileceğiniz bir komut satırı aracıdır:

<shell>
$ rails console
</shell>

Konsol yüklendikten sonra, onu uygulamanızın modelleri ile çalışmak için kullanabilirsiniz:

<shell>
>> p = Post.new(:content => "Yeni bir gönderi")
=> #<Post id: nil, name: nil, title: nil,
     content: "A new post", created_at: nil,
     updated_at: nil>
>> p.save
=> false
>> p.errors
=> #<OrderedHash { :title=>["can't be blank",
                           "is too short (minimum is 5 characters)"],
                   :name=>["can't be blank"] }>
</shell>

Bu kod yeni bir +Post+ örneği oluşturulduğunu, kaydetmeye kalkınca +false+ cevabı alındığını (ki bu kayıt işleminin gerçekleşmediğini gösterir) ve gönderi verisindeki hatayı +errors+ ile görmeyi gösteriyor.

Bitirdiğinizde +exit+ yazın ve +return+ basarak konsoldan çıkabilirsiniz.

TIP: Geliştirme modundaki web server'ın aksine konsol her seferinde kodunuzu tekrar yüklemez. Bu yüzden konsol açıkken modelde değişiklik yaparsanız +reload+ komutu girerek tazeleme sağlamalısınız.

h4. Tüm Gönderilerin Listelenmesi

Çalışmanın incelenmesinde en kolay yol gönderilerin listelendiği sayfayı incelemek. +app/controllers/posts_controller.rb+ dosyasını açın ve +index+ eylemine bakın:

<ruby>
def index
  @posts = Post.all

  respond_to do |format|
    format.html # index.html.erb
    format.xml  { render :xml => @posts }
  end
end
</ruby>

+Post.all+ deyimi +Post+ modelinden veritabanındaki tüm gönderileri getirir. Bunun sonucunda +@posts+ değişkeninde bir array olarak gönderileri saklıyoruz.

TIP: Active Record hakkında daha fazla bilgi için "Active Record Query Interface":active_record_querying.html başlığına bakınız.

+respond_to+ bloğu hem HTML hem XML olarak gelen çağrıları cevaplar. Eğer tarayıcıda "http://localhost:3000/posts.xml":http://localhost:3000/posts.xml adresine giderseniz tüm göderileri XML formatında görürsünüz. HTML formatı +app/views/posts/+ içindeki view dosyalarından ilgili eylemin dosyasına göre bir görüntü döner. Rails ilgili eylem içindeki tüm instance değişkenleri görsel için de kullanılabilir hale getirir. +app/views/posts/index.html.erb+ dosyasını inceleyelim:

<erb>
<h1>Listing posts</h1>

<table>
  <tr>
    <th>Name</th>
    <th>Title</th>
    <th>Content</th>
    <th></th>
    <th></th>
    <th></th>
  </tr>

<% @posts.each do |post| %>
  <tr>
    <td><%= post.name %></td>
    <td><%= post.title %></td>
    <td><%= post.content %></td>
    <td><%= link_to 'Show', post %></td>
    <td><%= link_to 'Edit', edit_post_path(post) %></td>
    <td><%= link_to 'Destroy', post, :confirm => 'Are you sure?', :method => :delete %></td>
  </tr>
<% end %>
</table>

<br />

<%= link_to 'New post', new_post_path %>
</erb>

Bu görsel dosyası, +@posts+ array değişkeni üzerinden gönderileri listeliyor ve ilgili linkleri elde ediyor. Görsel içinde birkaç noktaya dikkat edersek:

* +link_to+ bir hyperlink bağlantısı oluşturur
* +edit_post_path+ ve +new_post_path+ Rails'in RESTful yönlendirmelerinde kullandığı yardımcı tekniklerinden gelir. Kontrolörler içinde bu yardımcılardan birçok daha göreceksiniz.

NOTE. Rails'in önceki versiyonunda, +&lt;%=h post.name %&gt;+ kullanarak veri içine konan HTML kodlarının sayfada işlem yapması ve sayfanın saldırıya uğraması engellenirdi. Rails 3.0'da bu işlem default olarak yapılır. HTML kodların çalışmasını istiyorsanız +&lt;%= raw post.name %&gt;+ şeklinde yazmalısınız.

TIP: Render işlemi için ayrıntılı bilgiyi "Layouts and Rendering in Rails":layouts_and_rendering.html. adresinde bulabilirsiniz.

h4. Yerleşimin Düzenlenmesi

Görsel dosyalarında sadece tarayıcıda HTML'in nasıl görüneceği bilgisi vardır. Rails'de bundan başka +yerleşimler+ (layout) de bulunur. Bunlar görsellerin içine konacağı dosyalardır. Rails tarayıcıya bir görseli dönerken, görselin HTML kodunu yerleşimin HTML kodu içersine yerleştirir ve bu birleşimi döndürür. Rails'in önceki versiyonunda +rails generate scaffold+ komutu çalışınca otomatik olarak kontrolöre ait bir yerleşim dosyası (app/views/layouts/posts.html.erb gibi) üretilirdi. Rails 3.0'da bu değişti. Uygulama çapında bir +yerleşim+ tüm kontrolörler için kullanılır, +app/views/layouts/application.html.erb+. Bu yerleşim dosyasını editörde açın ve +body+ tag'ini değiştirin:

<erb>
<!DOCTYPE html>
<html>
<head>
  <title>Blog</title>
  <%= stylesheet_link_tag :all %>
  <%= javascript_include_tag :defaults %>
  <%= csrf_meta_tags %>
</head>
<body style="background: #EEEEEE;">

<%= yield %>

</body>
</html>
</erb>

Şimdi +/posts+ sayfasını tazelediğinizde sayfa arkaplanın gri renk olduğunu göreceksiniz. Aynı arkaplan tüm görsellerde gri olacaktır.

h4. Yeni Gönderiler Oluşturmak

Yeni gönderi oluşturmak iki eylemden oluşur. İlkönce +new+ eylemi boş bir +Post+ objesi başlatarak yeni gönderi oluşturur:

<ruby>
def new
  @post = Post.new

  respond_to do |format|
    format.html # new.html.erb
    format.xml  { render :xml => @post }
  end
end
</ruby>

+new.html.erb+ görseli kullanıcıya boş bir gönderi gösterir:

<erb>
  <h1>New post</h1>

  <%= render 'form' %>

  <%= link_to 'Back', posts_path %>
</erb>

+&lt;%= render 'form' %&gt;+ satırı Rails'de _partial_ konusuna ilk girişimizi oluşturacak. Bir partial (kısmi kod), birçok yerde tekrar kullanmak için hazırlanmış Ruby ve HTML kodlardan oluşan kod parçasıdır. Bizim uygulamamızda yeni gönderi oluşturmak için kullanılan form ile olan bir gönderiyi değiştirmek için kullanılan form aynıdır. Her ikisinde de isim ve başlık için birer text field, içerik için bir text area ve gönderiyi kaydetmek için bir buton vardır.

Eğer +views/posts/_form.html.erb+ dosyasına bakarsanız, şunları göreceksiniz:

<erb>
<%= form_for(@post) do |f| %>
  <% if @post.errors.any? %>
  <div id="error_explanation">
    <h2><%= pluralize(@post.errors.count, "error") %> prohibited this post from being saved:</h2>
    <ul>
    <% @post.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
  <% end %>

  <div class="field">
    <%= f.label :name %><br />
    <%= f.text_field :name %>
  </div>
  <div class="field">
    <%= f.label :title %><br />
    <%= f.text_field :title %>
  </div>
  <div class="field">
    <%= f.label :content %><br />
    <%= f.text_area :content %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>
</erb>

Bu kısmi kod tüm instance değişkenleri kendisini çağıran görselden alır ve kullanır, burada yeni gönderi kontrolör tarafından +@post+ değişkenine konur. Hem yeni gönderi hem değiştirme yaparken kontrolör +@post+ değişkenini kullanmaktadır. 

Kısmi kodlar hakkında daha fazla bilgi "Layouts and Rendering in Rails":layouts_and_rendering.html#using-partials klavuzunda bulunabilir.

+form_for+ bloğu bir HTML form üretmek için kullanılır. Bu blok içinde form içerisinde değişik kontroller oluşturmak için metodlar kullanabilirsiniz. Örneğin, +f.text_field :name+ komutu Rails'e form üzerinde bir text input oluşturmasını ve bunu instance değişkenin +name+ sütununu gösterecek şekilde bağlamasını anlatır. Bu metodları sadece formun bağlı olduğu modelin sütunlarına bağlamak için kullanabilirsiniz (yani burada +name+, +title+ ve +content+ ). Rails, +form_for+ yapısını az kodlama yapma amacıyla ve bir modelle direk bağlantı yaptığı için HTML koda tercih eder.

+form_for+ bloğu ayrıca yeni gönderi veya gönderi değiştirme eylemlerinin hangisinin istendiğini çözecek ve formun +action+ tag'i ve gönderi butonu etiketini isteğe göre tayin edecek kadar akıllıdır.

TIP: Eğer bir modele bağlı olmayan keyfi alanları olan bir HTML form oluşturmak isterseniz +form_tag+ metodunu kullanın. Bu bir modele bağlı olmayan formlar oluşturmak için gereken metodları kullanır.

Kullanıcı bu form üzerindeki +Create Post+ düğmesini tıkladığında tarayıcı bilgiyi kontrolörün +create+ eylemine gönderir (Rails +create+ metodunu çağıracağını bilir çünkü form bir HTTP POST isteği ile gönderilmiştir, bu daha önce anlattığımız geleneklerdendir):

<ruby>
def create
  @post = Post.new(params[:post])

  respond_to do |format|
    if @post.save
      format.html { redirect_to(@post,
                    :notice => 'Post was successfully created.') }
      format.xml  { render :xml => @post,
                    :status => :created, :location => @post }
    else
      format.html { render :action => "new" }
      format.xml  { render :xml => @post.errors,
                    :status => :unprocessable_entity }
    end
  end
end
</ruby>

+create+ eylemi formun gönderdiği verilerle yeni bir Post nesnesi üretir, veriyi +params+ hash yapısından alır. Yeni gönderiyi sağlıklı bir şekilde kaydederse +create+ eylemi kullanıcının girişi yaptığı formatta (burada HTML) kaydı gösteren sayfaya döner. Kullanıcıyı üretilen gönderinin +show+ eylemine yönlendirir ve bir bildiriyle kullanıcıya işlemin başarısını bildirir.

Eğer gönderi sağlıklı kaydedilemediyse, mesela denetleme hatası olduysa, kullanıcı tekrar +new+ eylemine yönlendirilip düzeltilip tekrar girilmesini belirten bir hata mesajı verilir.

"Post was successfully created." mesajı Rails'in +flash+ hash yapısında saklanır ve böylece mesaj kullanıcıyı yönlendirecek yardımcı bir mesajla diğer bir eyleme taşınabilir. +create+ eylemi kaydı saklarken başka bir görsele gitmeyip saklamanın ardından +show+ eylemine yönlendiği için bu sayfanın üzerinde "Post was successfully created." mesajı çıkar.

h4. Bir Gönderinin Ayrıntısının Gösterilmesi

Index sayfasında bir gönderinin +show+ linkine tıkladığınızda, sizi +http://localhost:3000/posts/2+ gibi bir sayfaya yönlendirir. Rails bunu +show+ eylemine bir çağrı olarak işler ve +2+ sayısını +:id+ parametresi olarak algılar. İşte +show+ eylemi:

<ruby>
def show
  @post = Post.find(params[:id])

  respond_to do |format|
    format.html # show.html.erb
    format.xml  { render :xml => @post }
  end
end
</ruby>

+show+ eylemi +id+ değerine göre veritabanından bir gönderiyi bulmak için +Post.find+ metodunu kullanır. Kaydı bulduktan sonra Rails +show.html.erb+ ile bu veriyi gösterir:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>


<%= link_to 'Edit', edit_post_path(@post) %> |
<%= link_to 'Back', posts_path %>
</erb>

h4. Gönderileri Düzenlemek

Yeni gönderi oluştururken olduğu gibi bir gönderiyi düzenlemek de iki adımdır. İlk adım +edit_post_path(@post)+ adresine ilgili gönderiye bağlı bir çağrıdır. Bu kontrolördeki +edit+ eylemini çağırır:

<ruby>
def edit
  @post = Post.find(params[:id])
end
</ruby>

Talep edilen gönderiyi bulduktan sonra Rails +edit.html.erb+ 'yi kullanarak gönderiyi size gösterir:

<erb>
<h1>Editing post</h1>

<%= render 'form' %>

<%= link_to 'Show', @post %> |
<%= link_to 'Back', posts_path %>
</erb>

Yine +new+ eyleminde olduğu gibi +edit+ eylemi de +form+ kısmi kodunu kullanır. Ama bu sefer kontrolöre PUT eylemi gönderirlir ve gönderi butonu etiketinde "Update Post" yazar.

Bu görsel tarafından oluşturulan form, kontrolördeki +update+ eylemine yönlenir:

<ruby>
def update
  @post = Post.find(params[:id])

  respond_to do |format|
    if @post.update_attributes(params[:post])
      format.html { redirect_to(@post,
                    :notice => 'Post was successfully updated.') }
      format.xml  { head :ok }
    else
      format.html { render :action => "edit" }
      format.xml  { render :xml => @post.errors,
                    :status => :unprocessable_entity }
    end
  end
end
</ruby>

+update+ eyleminde Rails ilk önce "edit" görselinden gelen +:id+ parametresi yardımı ile düzenlenecek kaydı veritabanından bulur. +update_attributes+ methodu ile de gelen istek içerisinden tüm diğer kayıt bileşenlerini bulur. Eğer herşey başarılı giderse kullanıcı tekrar +show+ görseline yönlendirilir. Eğer bir problem varsa tekrar +edit+ görseline dönülerek hatanın düzeltilmesi istenir.

h4. Bir Gönderinin Silinmesi

Son olarak, +destroy+ linklerinden birine tıkladığınızda ilgili satırın id'sini +destroy+ eylemine gönderir:

<ruby>
def destroy
  @post = Post.find(params[:id])
  @post.destroy

  respond_to do |format|
    format.html { redirect_to(posts_url) }
    format.xml  { head :ok }
  end
end
</ruby>

+destroy+ metodu ilgili kaydı veritabanından silen bir Active Record model metodudur. Bunu yaptıktan sonra, gösterilecek birşey olmadığı için, Rails kullanıcıyı tekrar index görseline yönlendirir.

h3. İkinci bir Model Eklenmesi

Şimdiye kadar scaffold ile yapılan modelin nasıl olduğunu gördünüz, artık uygulamaya yeni bir model ekleme zamanı. İkinci model gönderilere yapılan yorumların işleneceği bir model olacak.

h4. Bir Model Üretilmesi

Rails'de Model'ler tekil isimdedir ve onlara karşı gelen veritabanı tabloları çoğul isimdedir. Yorumların saklandığı model için gelenek olarak Comment isimli bir model oluşturulur. Eğer scaffold'un tüm üretimlerini kullanmayacaksanız bile hala diğer model ve kontrolör üretimlerinde de jeneratör kullanabilirsiniz. Yeni bir model oluşturmak için terminalde şu komutu çalıştırın:

<shell>
$ rails generate model Comment commenter:string body:text post:references
</shell>

Bu komut şu dosyaları oluşturacak:

* +app/models/comment.rb+ - model dosyası
* +db/migrate/20100207235629_create_comments.rb+ - migration dosyası
* +test/unit/comment_test.rb+ and +test/fixtures/comments.yml+ - test verileri.

Önce +comment.rb+ dosyasına bakalım:

<ruby>
class Comment < ActiveRecord::Base
  belongs_to :post
end
</ruby>

Bu daha önce gördüğünüz +post.rb+ modeline benzer. Farkı +belongs_to :post+ satırı, bu satır bir Active Record bağlantısı kurar. Bu klavuzun ilerki bölümünde tablo bağlantıları hakkında bilgi edineceksiniz.

Modele ilave olarak, Rails ilgili tablonun üretilmesi için bir veritabanı birleştirme dosyası üretir:

<ruby>
class CreateComments < ActiveRecord::Migration
  def self.up
    create_table :comments do |t|
      t.string :commenter
      t.text :body
      t.references :post

      t.timestamps
    end
  end

  def self.down
    drop_table :comments
  end
end
</ruby>

+t.references+ satırı iki model arasında bir tablo ilişkisi kurar. Şimdi birleştirmeyi çalıştırın:

<shell>
$ rake db:migrate
</shell>

Rails sadece şimdiye kadar yapılmamış birleştirmeleri yapacak kadar akıllıdır, bu yüzden sadece şu satırları görürsünüz:

<shell>
==  CreateComments: migrating =================================================
-- create_table(:comments)
   -> 0.0017s
==  CreateComments: migrated (0.0018s) ========================================
</shell>

h4. Modelleri İlişkilendirmek

Active Record bağlamaları sayesinde iki model birbiriyle kolayca ilişkilendirilebilir. Buradaki gönderiler ve yorumları düşünülürse şöyle bir ilişkilendirme yapılmalıdır:

* Her yorum birtek gönderiye aittir
* Her gönderinin birçok yorumu olabilir

Gerçekte yukardaki anlatımların ingilizcesi Rails'in ilikilendirme için kullandığı komutlarla nerdeyse aynıdır. Comment modeli içersinde zaten bir tanesini gördünüz, bu satırla her yorumun birtek gönderiye ilişkilendirildiği anlatılıyor:

<ruby>
class Comment < ActiveRecord::Base
  belongs_to :post
end
</ruby>

İkinci ilişkilendirmeyi yapmak için +post.rb+ model dosyasını düzenlemeniz gerekir:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }

  has_many :comments
end
</ruby>

Bu iki tanıtma komutuyla bir kısım faydalı otomatik işlemi aktif etmiş oluyorsunuz. Örneğin +@post+ adında birtek gönderi içeren instance değişkeniniz olsun, bunun tüm yorumlarını +@post.comments+ metodu ile çağırabilirsiniz.

TIP: Active Record ilişkilendirmeleri hakkında daha fazla bilgi için "Active Record Associations":association_basics.html klavuzuna bakınız.

h4. Yorumlar İçin bir Yönlendirme Eklenmesi

+home+ kontrolöründe olduğu gibi Rails'e yorumları nerede belirtmemiz gerekiyor. +config/routes.rb+ dosyasını tekrar açalım, en üstte gönderiler için scaffold komutu sayesinde eklenmiş olan +resources :posts+ satırını göreceksiniz bu satırı şöyle düzenleyin:

<ruby>
resources :posts do
  resources :comments
end
</ruby>

Bu +yorumları+ +gönderiler+ altında _nested resource_ olarak yerleştirir. Bu gönderiler ile yorumları arasındaki hiyerarşik ilişkinin yönetilmesinin bir diğer parçasıdır.

TIP: Routing (yönlendirme) hakkında daha fazla bilgi için "Rails Routing from the Outside In":routing.html klavuzuna bakınız.

h4. Bir Kontrolör Üretilmesi

Bu elimizdek modele karşı gelen bir kontrolör üretmeniz gerekiyor. Tabiiki bunu bir generator ile yapacaksnız:

<shell>
$ rails generate controller Comments
</shell>

Bu dört dosya ve boş bir klasör oluşturur:

* +app/controllers/comments_controller.rb+ - Kontrolör
* +app/helpers/comments_helper.rb+ - Görsel yardımcı dosyası
* +test/functional/comments_controller_test.rb+ - Kontrolör için fonksiyon testleri
* +test/unit/helpers/comments_helper_test.rb+ - Helper için birim testleri
* +app/views/comments/+ - Kontrolörün görselleri buraya konacak

Tüm bloglarda olduğu gibi bizim okuyucularımız da yorumlarını gönderinin hemen altında yapmak isterler. Arkasından da tekrar gönderi sayfasının tazelenip yorumlarının eklenmiş olduğunu görmek isterler. Bunu yapmak için +CommentsController+ yorumları üretecek ve SPAM yorumları ayıklayacak metodlara sahip olmalıdır.

İlk önce, Post kontrolörün +show+ görselinde yorum eklemek için değişiklik yapacağız (+/app/views/posts/show.html.erb+) dosyasını açın:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<h2>Add a comment:</h2>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>

<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

Bu sayede gönderilerin gösterildiği sayfaya yeni yorum eklemeye yarayan bir form eklenir. Bu form +CommentsControlle+ in +create+ eylemini çağırır, şimdi bu eylemi yazalım:

<ruby>
class CommentsController < ApplicationController
  def create
    @post = Post.find(params[:post_id])
    @comment = @post.comments.create(params[:comment])
    redirect_to post_path(@post)
  end
end
</ruby>

Burda gönderilerin PostController'inden daha karmaşık işler var. Bu içiçe çalışmanın yan etkisi olarak her yorumun hangi gönderiye bağlı olduğunu bulmak için yapmanız gereken ayarlamalar. Bu yüzden ilk adımda ilgili gönderi find metoduyla bulunuyor.

Ek olarak, kod içinde ilişkilendirmenin getirdiği yardımcı bazı metodlar kullanılıyor. +@post.comments+ in (gönderi yorumlarının) +create+ metodunu kullanark yeni yorumu üretiyor ve kaydediyoruz. Bu sayede yorum otomatik olarak gönderiye bağlı olarak tabloya kaydedilecektir.

Yeni yorum üretilince kullanıcıyı +post_path(@post)+ yardımcısını kullanarak tekrar orjinal gönderi gösterim sayfasına yönlendiriyoruz. Daha önce gördüğümüz gibi bu +PostController+ in +show+ eylemine gönderir ve bu da +show.html.erb+ görselini gösterir. Yorumları da bu sayfada göstermemiz gerekiyor, bu yüzden +app/views/posts/show.html.erb+ dosyasını şöyle düzenleyelim.

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<h2>Comments</h2>
<% @post.comments.each do |comment| %>
  <p>
    <b>Commenter:</b>
    <%= comment.commenter %>
  </p>

  <p>
    <b>Comment:</b>
    <%= comment.body %>
  </p>
<% end %>

<h2>Add a comment:</h2>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>

<br />

<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

Şimdi gönderilere yorumlar ekleyebilir ve gönderi ile aynı sayfada izleyebilirsiniz.

h3. Düzeltmeler

Şimdi gönderilerimiz ve yorumlarımız çalışıyor, +app/views/posts/show.html.erb+ kalıp dosyasına baktığımızda çok uzun ve sakil görünmekte. Bunu temizlemek için kısmi kodlar kullanabiliriz.

h4. Kısmi Kodların Yayınlaması

İlk önce gönderilerin yorumlarının gösterilebilmesi için bir yorumlar kısmi kodu yapacağız. +app/views/comments/_comment.html.erb+ adında bir dosya üretin ve şunları içine koyun:

<erb>
<p>
  <b>Commenter:</b>
  <%= comment.commenter %>
</p>

<p>
  <b>Comment:</b>
  <%= comment.body %>
</p>
</erb>

Daha sonra +app/views/posts/show.html.erb+ içerisinde şu değişiklikleri yapın:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<h2>Comments</h2>
<%= render @post.comments %>

<h2>Add a comment:</h2>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>

<br />

<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

Bu kod ile +@post.comments+ array'inin her elemanı için +app/views/comments/_comment.html.erb+ kısmi kodu çağırılacaktır. +render+ metodu <tt>@post.comments</tt> elemanlarının içinde iterasyon yaptığı için, her yorumu kısmi kod içindeki aynı isimde bir yerel değişkene atar bu sayede kısmi kod içinde yorum işlenebilir.

h4. Kısmi Form Yayınlanması

Şimdi yorumların yenisini girmek için kullanılan formu da olması gereken yerine gönderelim. +app/views/comments/_form.html.erb+ dosyasını üretin ve içine şunları koyun:

<erb>
<%= form_for([@post, @post.comments.build]) do |f| %>
  <div class="field">
    <%= f.label :commenter %><br />
    <%= f.text_field :commenter %>
  </div>
  <div class="field">
    <%= f.label :body %><br />
    <%= f.text_area :body %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>
</erb>

Daha sonra +app/views/posts/show.html.erb+ dosyasını şöyle düzeltin:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<h2>Comments</h2>
<%= render @post.comments %>

<h2>Add a comment:</h2>
<%= render "comments/form" %>

<br />

<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

İkinci render satırı <tt>comments/form</tt> kısmi formu yayınlar, Rails buna bakınca  <tt>app/views/comments</tt> klasöründeki <tt>_form.html.erb</tt> dosyasını göstereceğini anlayacak kadar akıllıdır.

+@post+ nesnesi instance değişken olduğu için her kısmi koddan görülebilir.

h3. Yorumların Silinmesi

Bir blogda diğer önemli özellikte SPAM yorumların silinmesidir. Bunu yapmak için, +CommentsController+ in +DELETE+ eylemini çağıran bir bağlantı eklememiz gerekiyor.

İlk önce +app/views/comments/_comment.html.erb+ kısmi koduna delete bağlantısını ekleyelim:

<erb>
<p>
  <b>Commenter:</b>
  <%= comment.commenter %>
</p>

<p>
  <b>Comment:</b>
  <%= comment.body %>
</p>

<p>
  <%= link_to 'Destroy Comment', [comment.post, comment],
               :confirm => 'Are you sure?',
               :method => :delete %>
</p>
</erb>

Bu yeni "Destroy Comment" bağlantısına tıklayınca +CommentsController+ in <tt>DELETE /posts/:id/comments/:id</tt> eylemi çağrılır ve silmek istediğimiz yorum belirlenmiş olur. Şimdi comments kontrolörüne destroy eylemi ekleme zamanı:

<ruby>
class CommentsController < ApplicationController

  def create
    @post = Post.find(params[:post_id])
    @comment = @post.comments.create(params[:comment])
    redirect_to post_path(@post)
  end

  def destroy
    @post = Post.find(params[:post_id])
    @comment = @post.comments.find(params[:id])
    @comment.destroy
    redirect_to post_path(@post)
  end

end
</ruby>

+destroy+ eylemi aradığımız yorumu bulur onu <tt>@post.comments</tt> grubu içinde işaretler ve sildikten sonra tekrar gönderinin gösterildiği görsele geri yönlendirir.


h4. İlişkili Nesnelerin Silinmesi

Eğer bir gönderiyi silerseniz bağlantılı yorumları da silmek gerekir. Diğer durumda en azından veri tabanını boşyere işgal etmiş oluruz (gerçi veritabanı çok şişmeyecekse kayıtların silinmesi yerine pasifleştirilmesi tercih edilmelidir ama). Rails buna benzer durumlar için +dependent+ opsiyonunu kullanır. Post modelini , +app/models/post.rb+, şöyle değiştirin:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }
  has_many :comments, :dependent => :destroy
end
</ruby>

h3. Güvenlik

Eğer bloğunuzu online yayınlamışsanız, herkes gönderiler ve yorumlar eklemeye , değiştirmeye ve silmeye yetkili olacaktır.

Rails bu durumlar için çok basit bir HTTP yetkilendirme sistemi sağlar. İlkönce bu basit yetkilendiriciyi <tt>app/controllers/application_controller.rb</tt> dosyamızda aktif edelim:

<ruby>
class ApplicationController < ActionController::Base
  protect_from_forgery

  private

  def authenticate
    authenticate_or_request_with_http_basic do |user_name, password|
      user_name == 'admin' && password == 'password'
    end
  end

end
</ruby>

Tabiiki kullanıcı adı ve şifreyi istediğiniz gibi değiştirebilirsiniz. Bu metodu +ApplicationController+ içine koyduğumuz için tüm uygulamadan erişilebilir.

Sonra +PostsController+ içinde yetkisiz kişilerin işlem yapmasını engellemek için birşeyler yapmalıyız, burada Rails'in <tt>before_filter</tt> metodunu kullanabiliriz. Bu metod Rails'e önce bir metod çalıştırmsını ve metod sonucu izin verirse işleme devam edilmesini anlatır.

Before filter metodu kullanmak için bunu +PostsController+ in en başında +index+ ve +show+ dışında her eylem öncesi yetki istediğimizi belirtmeliyiz, bunun için şöyle yazın:

<ruby>
class PostsController < ApplicationController

  before_filter :authenticate, :except => [:index, :show]

  # GET /posts
  # GET /posts.xml
  def index
    @posts = Post.all
    respond_to do |format|
# snipped for brevity
</ruby>

Ayrıca sadece yetkili kişilerin yorumları silmesine izin vermek için +CommentsController+ açın ve şunu yazın:

<ruby>
class CommentsController < ApplicationController

  before_filter :authenticate, :only => :destroy

  def create
    @post = Post.find(params[:post_id])
# kalabalık etmesin diye kısaltıldı
</ruby>

Eğer şimdi yeni bir gönderi üretmeye kalkarsanız, basit HTTP yetkilendirme şifre giriş ekranı karşınıza çıkacaktır

!images/challenge.png(Basic HTTP Authentication Challenge)!


h3. Çok Modelli bir Form Yapmak

Yaptığınız bloğun bir diğer özelliği de gönderileri tag'leyebilmek olmalı. Bu özelliği sağlamak için uygulamanız aynı form içinde birden fazla modelle iletişim kurmalıdır. Rails içiçe formlar için destek vermektedir.

Bunu göstermek için, her gönderiye birçok tag bağlamak için gönderiyi oluşturduğunuz formun sağında bir yer açacağız. Önce tag'leri saklamak için yeni bir model oluşturalım:

<shell>
$ rails generate model tag name:string post:references
</shell>

Tekrar birleştirmeyi çalıştırarak veritabanında tabloyu oluşturalım:

<shell>
$ rake db:migrate
</shell>

Sonra, ilişkilendirmenin diğer tarafı için +post.rb+ dosyasını düzenleyin ve Rails'e tag'eri gönderilerle beraber düzenleyeceğinizi ( +accepts_nested_attributes_for+ makrosu yoluyla) anlatın:

<ruby>
class Post < ActiveRecord::Base
  validates :name,  :presence => true
  validates :title, :presence => true,
                    :length => { :minimum => 5 }

  has_many :comments, :dependent => :destroy
  has_many :tags

  accepts_nested_attributes_for :tags, :allow_destroy => :true,
    :reject_if => proc { |attrs| attrs.all? { |k, v| v.blank? } }
end
</ruby>

İçiçe özellik tanımlamasındaki +:allow_destroy+ opsiyonu Rails'e ilerde yapacağınız görsel içinde "remove" checkbox bulunması gerektiğini anlatır. +:reject_if+ opsiyonu hiç bir özelliği tanımlanmamış yeni tag'lerin kaydedilmesini engeller.

+views/posts/_form.html.erb+ dosyasını tag üreten bir kısmi kod haline getirmek için değiştirin:

<erb>
<% @post.tags.build %>
<%= form_for(@post) do |post_form| %>
  <% if @post.errors.any? %>
  <div id="errorExplanation">
    <h2><%= pluralize(@post.errors.count, "error") %> prohibited this post from being saved:</h2>
    <ul>
    <% @post.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
  <% end %>

  <div class="field">
    <%= post_form.label :name %><br />
    <%= post_form.text_field :name %>
  </div>
  <div class="field">
    <%= post_form.label :title %><br />
    <%= post_form.text_field :title %>
  </div>
  <div class="field">
    <%= post_form.label :content %><br />
    <%= post_form.text_area :content %>
  </div>
  <h2>Tags</h2>
  <%= render :partial => 'tags/form',
             :locals => {:form => post_form} %>
  <div class="actions">
    <%= post_form.submit %>
  </div>
<% end %>
</erb>

Dikkat ederseniz ne olduğunu daha iyi anlamak için +form_for(@post) do |f|+ deki +f+ yerine +post_form+ yazdık.

Bu örnek render yardımcısının bir diğer opsiyonunu gösteriyor, yerel değşkenlere erişme kabiliyeti, bu konumda yerel değişken +form+ un +post_form+ nesnesine bağlanmasını istiyoruz.

Ayrıca formun en üstüne <tt>@post.tags.build</tt> ekledik, bu kullanıcı tarafından adı girilmiş yeni bir tag olduğundan emin olmak içindir. Eğer yeni bir tag yapılmadıysa form da görünmeyecektir.

Şimdi <tt>app/views/tags</tt> klasörünü ve içinde tag için formu içeren <tt>_form.html.erb</tt> dosyasını üretin:

<erb>
<%= form.fields_for :tags do |tag_form| %>
  <div class="field">
    <%= tag_form.label :name, 'Tag:' %>
    <%= tag_form.text_field :name %>
  </div>
  <% unless tag_form.object.nil? || tag_form.object.new_record? %>
    <div class="field">
      <%= tag_form.label :_destroy, 'Remove:' %>
      <%= tag_form.check_box :_destroy %>
    </div>
  <% end %>
<% end %>
</erb>

Son olarak, <tt>app/views/posts/show.html.erb</tt> kalıbını tag'lermizi gösterecek şekilde düzenleyeceğiz.

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<p>
  <b>Tags:</b>
  <%= @post.tags.map { |t| t.name }.join(", ") %>
</p>

<h2>Comments</h2>
<%= render @post.comments %>

<h2>Add a comment:</h2>
<%= render "comments/form" %>


<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

Bu değişikliklerle birlikte aynı görüntü içinde gönderilerle beraber tag'lerin de düzenlenebildiğini göreceksiniz.

Bununla beraber şu metod çağrısı <tt>@post.tags.map { |t| t.name }.join(", ")</tt> çirkin oldu bunu bir yardımcı (helper) metod yaparak düzenleyebiliriz.

h3. Görsel Yardımcıları

Görsel yardımcıları <tt>app/helpers</tt> klasöründe yaşar ve görseller için tekrar tekrar kullanabilen kod parçalarıdır. Bizim konumuzda bir kaç nesnenin name özelliğini toplayıp aralarına virgül koyarak birleştiren bir koda ihtiyacımız var. Bu işlem Post görselinde lazım olduğu için PostHelper içine kodumuzu koyacağız.

<tt>app/helpers/posts_helper.rb</tt> dosyasını açın ve şunları yazın:

<ruby>
module PostsHelper
  def join_tags(post)
    post.tags.map { |t| t.name }.join(", ")
  end
end
</ruby>

Şimdi <tt>app/views/posts/show.html.erb</tt> görselini şöyle düzenleyebilirsiniz:

<erb>
<p class="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @post.name %>
</p>

<p>
  <b>Title:</b>
  <%= @post.title %>
</p>

<p>
  <b>Content:</b>
  <%= @post.content %>
</p>

<p>
  <b>Tags:</b>
  <%= join_tags(@post) %>
</p>

<h2>Comments</h2>
<%= render @post.comments %>

<h2>Add a comment:</h2>
<%= render "comments/form" %>


<%= link_to 'Edit Post', edit_post_path(@post) %> |
<%= link_to 'Back to Posts', posts_path %> |
</erb>

h3. Sırada Ne Var?

Artık ilk Rails uygulamanız hazır, istediğiniz gibi tecrübe edebilir ve değiştirebilirsiniz. Ama bunu yardımsız yapmak zorunda değilsiniz. Rails çalışmalarınız esnasında yrdıma ihtiyaç duyarsanız bu kaynaklara başvurabilirsiniz:

* The "Ruby on Rails guides":index.html
* The "Ruby on Rails Tutorial":http://railstutorial.org/book
* The "Ruby on Rails mailing list":http://groups.google.com/group/rubyonrails-talk
* The "#rubyonrails":irc://irc.freenode.net/#rubyonrails channel on irc.freenode.net
* The "Rails Wiki":http://wiki.rubyonrails.org/

Rails içinde de bir help vardır bunu rake komutu ile hazırlamanız gerekir:

* +rake doc:guides+ komutuyla tüm Rails klavuzları uygulamanızın +doc/guides+ klasörüne konur. +doc/guides/index.html+ dosyasını tarayıcınızda açın ve klavuzları inceleyin.
* +rake doc:rails+ komutuyla API dökümanın bir kopyası uygulamanızın +doc/api+ klasörüne konur. +doc/api/index.html+ dosyasını tarayıcınızda açın ve inceleyin.

h3. Konfigürasyon İpuçları

Rails ile çalışmanın en kolay yolu tüm harici verilerinizi UTF-8 olarak saklamanızdır. Eğer böyle yapmazsanız Ruby kütüphaneleri Rails sizin kendi dilnizin verilerini UTF-8 e dönüştürmeye çalışacak ama herzaman başarılı olamayacaktır. En iyisi tüm harici verileri UTF-8 saklamak olacaktır.

Bu hatayı yaptığınızda en belirgin görüntüsü tarayıcınızdaki içinde soru işareti olan siyah baklava olacaktır. Bir diğer belirti de "ü" harfinin "Ã¼" gibi görünmesidir. Rails takes a number of internal steps to mitigate common causes of these problems that can be automatically detected and corrected. However, if you have external data that is not stored as UTF-8, it can occasionally result in these kinds of issues that cannot be automatically detected by Rails and corrected.

Kaynak dosyalarınızın UTF-8 olmamasının iki sebebi vardır:
* Text editorünüz: Birçok text editörü dosyaları UTF-8 kaydeder. Eğer sizin editörünüz bu
  şekilde kaydetmiyorsa tarayıcıda görsellerde kullanmak üzere yazılarınızın karakterleri
  görünmeyecektir. Bu ayrıca I18N tercüme dosyalarınızı da etkiler. Mesela Dreamviewer
  default karakter seti UTF-8 değildir, ayarlanması gerekir.
* Veri Tabanınız: Rails default olarak veritabanınızdan gelen veriyi UTF-8 e çevirir.
  Ama veritabanınız içerde UTF-8 kullanmıyorsa kullanıcının girdiği tüm verileri
  saklamayabilir. Mesela veritabanınız Latin-1 kullanıyorsa ve kullanıcı Rusça veya
  Japonca gibi yazılar girerse veritbanına kaydedildiği anda veri kaybolacaktır.
  Mümkünse veritabanınızın içinde kayıtları UTF-8 olarak saklayın.

h3. Değişiklikler

* August 30, 2010: Minor editing after Rails 3 release by "Joost Baaij":http://www.spacebabies.nl
* July 12, 2010: Fixes, editing and updating of code samples by "Jaime Iniesta":http://jaimeiniesta.com
* May 16, 2010: Added a section on configuration gotchas to address common encoding problems that people might have by "Yehuda Katz":http://www.yehudakatz.com
* April 30, 2010: Fixes, editing and updating of code samples by "Rohit Arondekar":http://rohitarondekar.com
* April 25, 2010: Couple of more minor fixups "Mikel Lindsaar":credits.html#raasdnil
* April 1, 2010: Fixed document to validate XHTML 1.0 Strict. "Jaime Iniesta":http://jaimeiniesta.com
* February 8, 2010: Full re-write for Rails 3.0-beta, added helpers and before_filters, refactored code by "Mikel Lindsaar":credits.html#raasdnil
* January 24, 2010: Re-write for Rails 3.0 by "Mikel Lindsaar":credits.html#raasdnil
* July 18, 2009: Minor cleanup in anticipation of Rails 2.3.3 by "Mike Gunderloy":credits.html#mgunderloy
* February 1, 2009: Updated for Rails 2.3 by "Mike Gunderloy":credits.html#mgunderloy
* November 3, 2008: Formatting patch from Dave Rothlisberger
* November 1, 2008: First approved version by "Mike Gunderloy":credits.html#mgunderloy
* October 16, 2008: Revised based on feedback from Pratik Naik by "Mike Gunderloy":credits.html#mgunderloy (not yet approved for publication)
* October 13, 2008: First complete draft by "Mike Gunderloy":credits.html#mgunderloy (not yet approved for publication)
* October 12, 2008: More detail, rearrangement, editing by "Mike Gunderloy":credits.html#mgunderloy (not yet approved for publication)
* September 8, 2008: initial version by "James Miller":credits.html#bensie (not yet approved for publication)
